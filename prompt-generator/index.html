<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>이미지 프롬프트 생성기</title>
    
    <!-- CSS 파일 링크 -->
    <link rel="stylesheet" href="../assets/css/core.css">
    <link rel="stylesheet" href="../assets/css/concept-art-styles-unified.css">
    
    <!-- SEO -->
    <meta name="description" content="AI 이미지 생성을 위한 프롬프트 제작 도구">
    <meta name="keywords" content="AI 이미지생성, 프롬프트, Midjourney, DALL-E, Stable Diffusion">
    
    <!-- 파비콘 -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🖼️</text></svg>">
    
    <style>
        /* 큰 팝업 숨기기 - 외부 CSS 오버라이드 */
        .popup, .modal, .overlay, .dialog, .popup-overlay, .modal-backdrop {
            display: none !important;
        }
        
        /* API 모달만 예외 처리 */
        #api-modal.modal-overlay {
            display: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        #api-modal.modal-overlay.show {
            display: flex !important;
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        /* 토스트는 기본적으로 숨김 */
        #toast.toast {
            display: none;
        }
        
        #toast.toast.show {
            display: flex !important;
            opacity: 1 !important;
            transform: translateX(0) !important;
        }
        
        /* 페이지 특화 스타일 */
        .main-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: var(--space-lg);
            padding-top: 80px;
            padding-bottom: 100px; /* 하단 드롭다운을 위한 여백 */
            position: relative;
            z-index: 1;
        }
        
        /* PC에서 적절한 컨텐츠 너비 유지 */
        @media (min-width: 1200px) {
            .main-container {
                padding-left: 3%;
                padding-right: 3%;
            }
        }

        .section {
            background: var(--bg-card);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-md);
            position: relative;
            /* 드롭다운이 섹션 밖으로 나갈 때 잘리지 않도록 */
            overflow: visible;
        }

        .section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-gradient);
            opacity: 0.8;
        }

        .section-header {
            margin-bottom: var(--space-sm);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .section-header-left {
            flex: 1;
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section-subtitle {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 400;
        }

        /* 입력 영역 스타일 */
        .input-area {
            display: block;
            margin-bottom: var(--space-md);
        }
        

        .input-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            transition: all var(--transition-base);
        }

        .input-section:hover {
            border-color: rgba(168, 85, 247, 0.5);
            box-shadow: 0 0 15px rgba(168, 85, 247, 0.1);
        }

        .input-section h3 {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: var(--space-sm);
            color: var(--text-primary);
            word-break: keep-all;
            white-space: normal;
        }

        .text-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            color: var(--text-primary);
            font-family: 'Paperlogy', sans-serif;
            font-size: 0.85rem;
            resize: vertical;
            min-height: 150px;
            transition: all var(--transition-base);
        }

        .text-input:focus {
            outline: none;
            border-color: var(--accent-purple);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.2);
        }


        /* 이미지 프리뷰 */
        .image-preview {
            width: 100%;
            max-height: 200px;
            object-fit: contain;
            border-radius: var(--radius-sm);
            margin-top: var(--space-sm);
        }

        .remove-image-btn {
            position: absolute;
            top: var(--space-xs);
            right: var(--space-xs);
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border: none;
            border-radius: var(--radius-full);
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all var(--transition-base);
        }

        .remove-image-btn:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.1);
        }

        /* 버튼 그룹 */
        .button-group {
            display: flex;
            gap: var(--space-sm);
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .btn {
            padding: 6px 16px;
            border: none;
            border-radius: var(--radius-full);
            font-family: 'Paperlogy', sans-serif;
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all var(--transition-base);
            display: inline-flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .btn-primary {
            background: var(--primary-gradient);
            color: white;
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn-export {
            background: var(--accent-gradient);
            color: white;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }

        .btn-export:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4);
        }

        /* 생성된 프롬프트 영역 */
        .output-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-sm);
            padding: var(--space-md);
            margin-top: var(--space-md);
            display: none;
        }

        .output-section.active {
            display: block;
        }

        .output-text {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            color: var(--text-primary);
            font-family: 'Paperlogy', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .copy-btn {
            margin-top: var(--space-sm);
            background: var(--secondary-gradient);
            color: white;
        }

        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(139, 92, 246, 0.4);
        }

        /* 프롬프트 새로고침 버튼 스타일 */
        .prompt-clear-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.6);
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            height: 32px;
            position: relative;
            overflow: hidden;
        }

        .prompt-clear-btn:hover {
            background: rgba(168, 85, 247, 0.15);
            border-color: rgba(168, 85, 247, 0.4);
            color: rgba(168, 85, 247, 0.9);
            transform: rotate(180deg);
        }

        .prompt-clear-btn:active {
            transform: rotate(180deg) scale(0.9);
        }

        .prompt-clear-btn svg {
            transition: transform 0.3s ease;
        }

        .prompt-clear-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(168, 85, 247, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.4s ease, height 0.4s ease;
        }

        .prompt-clear-btn:hover::before {
            width: 40px;
            height: 40px;
        }

        /* 프롬프트 입력 영역 */
        .prompt-preview-section {
            margin-top: var(--space-lg);
            margin-bottom: var(--space-md);
        }
        
        /* 프롬프트 카드 섹션 전체 너비 보장 */
        #prompt-cards-section {
            width: 100%;
            /* 드롭다운이 화면 하단에 닿아도 여유 공간 확보 */
            padding-bottom: calc(var(--space-xl, 48px));
        }
        
        #prompt-cards-grid {
            width: 100%;
        }

        .preview-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .prompt-preview {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            padding: var(--space-md);
            min-height: 80px;
            font-family: 'Paperlogy', monospace;
            font-size: 0.85rem;
            line-height: 1.5;
            color: var(--text-primary);
            transition: all var(--transition-base);
        }

        .prompt-preview:hover {
            border-color: rgba(168, 85, 247, 0.3);
            background: rgba(255, 255, 255, 0.05);
        }

        .preview-placeholder {
            color: var(--text-tertiary);
            font-style: italic;
            margin: 0;
        }

        .prompt-preview.has-content {
            color: var(--text-primary);
            font-style: normal;
        }

        /* 프롬프트 입력 가능 스타일 */
        .prompt-preview[contenteditable="true"] {
            cursor: text;
            outline: none;
            min-height: 100px;
        }
        .prompt-preview:focus {
            border-color: rgba(168, 85, 247, 0.5);
            background: rgba(255, 255, 255, 0.06);
        }

        /* 구조 편집기 탭 스타일 */
        .structure-tabs {
            margin-bottom: var(--space-md);
        }
        
        .structure-tab-buttons { 
            display: flex; 
            gap: var(--space-xs); 
            margin-bottom: var(--space-xs); 
        }
        
        .structure-tab-button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: var(--radius-sm);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-base);
        }
        
        .structure-tab-button:hover { 
            border-color: rgba(168, 85, 247, 0.35); 
            background: rgba(168, 85, 247, 0.05);
        }
        
        .structure-tab-button.active {
            background: rgba(168, 85, 247, 0.15);
            border-color: rgba(168, 85, 247, 0.35);
            color: white;
        }
        
        /* 구조 편집기 섹션 스타일 */
        .structure-section {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            padding: var(--space-md);
            margin-bottom: var(--space-sm);
        }
        
        .structure-section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent-purple);
            margin-bottom: var(--space-sm);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* 캐릭터 컨테이너 스타일 */
        .character-container {
            width: 100% !important;
            display: flex;
            flex-direction: column;
            max-width: none !important;
        }
        /* 일반이미지 컨테이너도 동일 스타일 적용 */
        .general-container {
            width: 100% !important;
            display: flex;
            flex-direction: column;
            max-width: none !important;
        }
        
        /* 캐릭터 하위 탭 스타일 */
        .character-sub-tabs {
            margin-bottom: var(--space-md);
            width: 100%;
        }
        
        .sub-tab-buttons {
            display: flex;
            gap: var(--space-xs);
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
            padding-bottom: var(--space-xs);
            width: 100%;
        }
        
        .sub-tab-button {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 8px 20px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-base);
            position: relative;
        }
        
        .sub-tab-button:hover {
            color: var(--text-primary);
        }
        
        .sub-tab-button.active {
            color: var(--accent-purple);
        }
        
        .sub-tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-purple);
        }
        
        /* 하위 탭 컨텐츠 스타일 */
        .sub-tab-contents {
            min-height: 0; /* 콘텐츠 높이에 맞춰 자동 */
            width: 100%;
            padding-bottom: 0; /* 캐릭터 시트 하단과 바로 맞닿도록 */
        }
        
        .sub-tab-content {
            display: none;
            width: 100%;
            position: relative;
        }
        
        .sub-tab-content.active {
            display: block;
        }
        
        /* 캐릭터 테이블 스타일 */
        .character-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .character-row {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: all var(--transition-base);
        }
        
        .character-row:hover {
            background: rgba(255, 255, 255, 0.02);
        }
        
        .character-row td {
            padding: var(--space-sm) var(--space-md);
            vertical-align: middle;
        }
        
        .style-column {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
            width: 150px;
            text-align: center;
            font-size: 0.85rem;
            white-space: nowrap;
            padding: var(--space-sm) var(--space-md);
        }
        
        .item-number {
            color: var(--text-tertiary);
            font-size: 0.85rem;
            min-width: 40px;
            font-weight: 500;
            text-align: center;
        }
        
        .item-key {
            color: var(--accent-purple);
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 150px;
        }
        
        .item-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-sm);
            padding: 8px 12px;
            color: var(--text-primary);
            font-family: 'Paperlogy', sans-serif;
            font-size: 0.85rem;
            transition: all var(--transition-base);
        }
        
        .item-input.change-request {
            background-color: rgba(255, 255, 255, 0.03);
        }
        
        .item-input.change-applied {
            background-color: rgba(240, 248, 255, 0.05);
        }
        
        /* 드롭다운 스타일 */
        .dropdown-container {
            margin-bottom: var(--space-md);
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            overflow: hidden;
            transition: all var(--transition-base);
            position: relative;
        }
        
        .dropdown-container.active {
            overflow: visible;
        }
        
        .dropdown-container:hover {
            border-color: rgba(168, 85, 247, 0.3);
            box-shadow: 0 4px 20px rgba(168, 85, 247, 0.1);
        }
        
        .dropdown-container.active {
            border-color: var(--accent-purple);
            box-shadow: 0 6px 24px rgba(168, 85, 247, 0.2);
        }
        
        .dropdown-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-md);
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
            cursor: pointer;
            transition: all var(--transition-base);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .dropdown-header:hover {
            background: rgba(168, 85, 247, 0.1);
            border-bottom-color: var(--accent-purple);
        }
        
        .dropdown-title {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-weight: 600;
            font-size: 0.95rem;
        }
        
        .dropdown-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: var(--accent-purple);
            color: white;
            border-radius: var(--radius-full);
            font-size: 0.85rem;
            font-weight: 700;
            transition: all var(--transition-base);
        }
        
        .dropdown-container:hover .dropdown-number {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transform: scale(1.1);
        }
        
        .dropdown-arrow {
            transition: transform var(--transition-base);
            font-size: 1.2rem;
            color: var(--accent-purple);
        }
        
        .dropdown-container:hover .dropdown-arrow {
            color: var(--text-primary);
        }
        
        .dropdown-english-label {
            display: inline-block;
            background: var(--accent-green);
            color: white;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: var(--space-xs);
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        
        .dropdown-container:hover .dropdown-english-label {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }
        
        /* Select-Input 하이브리드 스타일 */
        .select-input-wrapper {
            position: relative;
            width: 100%;
        }
        
        .dropdown-field-input.with-select {
            padding-right: 35px;
        }
        
        .dropdown-toggle-btn {
            position: absolute;
            right: 1px;
            top: 1px;
            bottom: 1px;
            width: 30px;
            background: var(--accent-purple);
            border: none;
            border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-base);
        }
        
        .dropdown-toggle-btn:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .dropdown-icon {
            font-size: 0.8rem;
            transition: transform var(--transition-base);
        }
        
        .dropdown-toggle-btn.active .dropdown-icon {
            transform: rotate(180deg);
        }
        
        .style-options-dropdown {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            background: rgba(30, 30, 35, 0.98);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-md);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            z-index: 10000;
            max-height: 340px;
            overflow: auto;
            display: flex;
            flex-direction: column;
            pointer-events: auto;
        }
        
        .style-options-search {
            padding: var(--space-sm);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
        }
        
        .style-options-search input {
            width: 100%;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-size: 0.8rem;
        }
        
        .style-options-list {
            overflow-y: auto;
            max-height: 250px;
            background: rgba(20, 20, 25, 0.6);
        }
        
        .style-option {
            padding: 8px 12px;
            cursor: pointer;
            transition: all var(--transition-base);
            font-size: 0.85rem;
            color: var(--text-secondary);
            position: relative;
        }
        
        .style-option:hover {
            background: rgba(168, 85, 247, 0.1);
            color: var(--text-primary);
            padding-left: 16px;
        }
        
        .style-option.selected {
            background: rgba(168, 85, 247, 0.2);
            color: var(--accent-purple);
            font-weight: 600;
            position: relative;
            padding-right: 35px;
        }
        
        .style-option.selected::after {
            content: '✓';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--accent-purple);
            font-size: 1rem;
        }
        
        .style-option.focused {
            background: rgba(168, 85, 247, 0.15);
            color: var(--text-primary);
            outline: 2px solid var(--accent-purple);
            outline-offset: -2px;
        }
        
        .style-option.hidden {
            display: none;
        }
        
        .dropdown-container.active .dropdown-arrow {
            transform: rotate(180deg);
        }
        
        .dropdown-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.25s ease-out;
            background: rgba(255, 255, 255, 0.02);
            position: relative;
        }
        
        .dropdown-container.active .dropdown-content {
            max-height: 420px;
            overflow: visible;
        }
        
        .dropdown-fields {
            padding: var(--space-md);
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-md);
            position: relative;
        }
        
        .dropdown-field {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
            position: relative;
        }
        
        
        .field-action-buttons {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }
        
        .btn-field-action {
            padding: 4px 8px;
            font-size: 0.7rem;
            border: none;
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition-base);
            font-weight: 500;
            white-space: nowrap;
        }
        
        .btn-save {
            background: var(--accent-green);
            color: white;
        }
        
        .btn-save:hover {
            background: #059669;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }
        
        .btn-ai-save {
            background: var(--accent-purple);
            color: white;
        }
        
        .btn-ai-save:hover {
            background: #9333EA;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(168, 85, 247, 0.3);
        }
        
        .dropdown-field-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-xs);
            display: block;
            line-height: 20px;
            min-height: 20px;
        }
        
        .dropdown-field-label-with-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-xs);
            height: 20px; /* 라벨 영역 높이 고정 */
        }
        
        .dropdown-field-label-with-buttons .dropdown-field-label {
            margin-bottom: 0;
        }
        
        .dropdown-field-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-sm);
            padding: 10px 14px;
            color: var(--text-primary);
            font-family: 'Paperlogy', sans-serif;
            font-size: 0.85rem;
            transition: all var(--transition-base);
        }
        
        .dropdown-field-input:focus {
            outline: none;
            border-color: var(--accent-purple);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.2);
            background: rgba(255, 255, 255, 0.08);
        }
        
        /* 모바일 드롭다운 스타일 */
        @media (max-width: 767px) {
            .dropdown-fields {
                grid-template-columns: 1fr;
                gap: var(--space-sm);
            }
            
            .dropdown-title {
                font-size: 0.85rem;
            }
            
            .dropdown-number {
                width: 24px;
                height: 24px;
                font-size: 0.75rem;
            }
            
            .dropdown-field-label-with-buttons {
                flex-wrap: wrap;
                gap: var(--space-xs);
            }
            
            .dropdown-field-label-with-buttons .field-action-buttons {
                width: 100%;
                order: 2;
                margin-top: var(--space-xs);
            }
            
            .btn-field-action {
                flex: 1;
                padding: 4px 6px;
                font-size: 0.65rem;
            }
        }
        
        .item-input:focus {
            outline: none;
            border-color: var(--accent-purple);
            background: rgba(255, 255, 255, 0.08);
        }
        

        /* 구조별 카드 섹션 */
        .prompt-cards-section {
            margin-top: 4px;
            margin-bottom: 4px;
            margin-left: calc(-1 * var(--space-sm));
            margin-right: calc(-1 * var(--space-sm));
            padding: var(--space-sm);
            background: rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: visible; /* 내부 드롭다운이 넘쳐도 보이도록 */
        }

        .cards-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
        }

        .cards-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            word-break: keep-all;
            white-space: normal;
        }

        .btn-import {
            background: var(--secondary-gradient);
            color: white;
            font-size: 0.8rem;
            padding: 6px 14px;
        }

        .btn-import:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .btn-sync {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            color: #3b82f6;
            transition: all var(--transition-base);
        }

        .btn-sync:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: #3b82f6;
        }
        
        /* 편집 모드 표시 스타일 */
        .prompt-preview.user-editing {
            border-color: rgba(251, 191, 36, 0.5);
            background: rgba(251, 191, 36, 0.05);
        }
        
        .edit-mode-indicator {
            position: absolute;
            top: -20px;
            right: 0;
            font-size: 0.75rem;
            color: #fbbf24;
            font-weight: 500;
        }

        .prompt-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: var(--space-sm);
        }
        
        /* 캐릭터/일반이미지 탭에서 prompt-cards-grid 오버라이드 */
        .prompt-cards-grid:has(.character-container),
        .prompt-cards-grid:has(.general-container) {
            display: block;
            width: 100%;
        }
        
        /* 큰 화면에서 더 많은 카드 표시 */
        @media (min-width: 1600px) {
            .prompt-cards-grid {
                grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
                gap: var(--space-md);
            }
        }

        .prompt-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            padding: var(--space-sm);
            transition: all var(--transition-base);
            position: relative;
        }

        .prompt-card:hover {
            border-color: rgba(168, 85, 247, 0.3);
            background: rgba(255, 255, 255, 0.05);
            transform: translateY(-1px);
        }

        .prompt-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-xs);
        }

        .prompt-card-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-purple);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .prompt-card-edit-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.9rem;
            padding: 2px 6px;
            border-radius: var(--radius-sm);
            transition: all var(--transition-base);
        }

        .prompt-card-edit-btn:hover {
            color: var(--accent-purple);
            background: rgba(168, 85, 247, 0.1);
        }

        .prompt-card-content {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.4;
            min-height: 40px;
        }

        .prompt-card-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-sm);
            padding: var(--space-xs);
            color: var(--text-primary);
            font-family: 'Paperlogy', sans-serif;
            font-size: 0.8rem;
            resize: vertical;
            min-height: 60px;
            display: none;
        }

        .prompt-card.editing .prompt-card-content {
            display: none;
        }

        .prompt-card.editing .prompt-card-input {
            display: block;
        }

        .prompt-card-actions {
            display: none;
            gap: var(--space-xs);
            margin-top: var(--space-xs);
        }

        .prompt-card.editing .prompt-card-actions {
            display: flex;
        }

        .prompt-card-btn {
            padding: 4px 12px;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-base);
        }

        .prompt-card-save {
            background: var(--accent-green);
            color: white;
        }

        .prompt-card-save:hover {
            background: rgba(16, 185, 129, 0.8);
        }

        .prompt-card-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }

        .prompt-card-cancel:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Hidden class for filtering */
        .hidden {
            display: none !important;
        }
        
        /* 토스트 메시지 - 삭제 (중복 정의) */

        /* 태블릿 디자인 (768px - 1199px) */
        @media (min-width: 768px) and (max-width: 1199px) {
            .main-container {
                padding-left: var(--space-md);
                padding-right: var(--space-md);
            }
        }

        /* 모바일 디자인 */
        @media (max-width: 767px) {
            /* 캐릭터 테이블 스타일 제거 - 드롭다운으로 대체 */
            
            .sub-tab-buttons {
                flex-wrap: wrap;
            }
            
            .sub-tab-button {
                padding: 6px 12px;
                font-size: 0.8rem;
            }
            
            .input-area {
                grid-template-columns: 1fr;
                gap: var(--space-sm);
            }

            .button-group {
                justify-content: center;
                gap: 8px;
                flex-wrap: wrap;
            }

            .main-container {
                padding: var(--space-sm);
                padding-top: 70px;
                max-width: 100%;
            }
            
            .section {
                padding: var(--space-sm);
                margin-bottom: var(--space-sm);
            }
            
            .section-header {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--space-sm);
            }
            
            .section-header-left {
                width: 100%;
            }
            
            .section-title {
                font-size: 1rem;
                word-break: keep-all;
                white-space: normal;
            }
            
            .section-subtitle {
                font-size: 0.75rem;
                word-break: keep-all;
                white-space: normal;
            }
            
            .btn {
                padding: 6px 12px;
                font-size: 0.8rem;
                white-space: nowrap;
                min-width: auto;
            }
            
            .btn-ai-connect {
                width: 100%;
                justify-content: center;
            }
            
            .text-input {
                min-height: 120px;
                font-size: 0.8rem;
                word-break: break-word;
            }
            
            
            .prompt-preview-section {
                margin-top: var(--space-md);
                margin-bottom: var(--space-sm);
            }
            
            .prompt-preview {
                min-height: 60px;
                padding: var(--space-sm);
                font-size: 0.8rem;
                word-break: break-word;
                white-space: pre-wrap;
            }
            
            .preview-title {
                font-size: 0.85rem;
                word-break: keep-all;
            }
            
            .preview-placeholder {
                word-break: keep-all;
                white-space: normal;
            }
            
            .prompt-cards-grid {
                grid-template-columns: 1fr;
            }
            
            .prompt-card {
                padding: var(--space-xs);
            }
            
            .prompt-card-title {
                font-size: 0.8rem;
                word-break: keep-all;
            }
            
            .prompt-card-content {
                font-size: 0.75rem;
                word-break: break-word;
            }
            
            .cards-title {
                word-break: keep-all;
                white-space: normal;
                font-size: 0.8rem;
            }
            
            .cards-header {
                flex-direction: column;
                align-items: flex-start;
                gap: var(--space-xs);
            }
            
            .btn-import {
                width: 100%;
                font-size: 0.8rem;
                padding: 6px 12px;
            }
        }
        
        /* 초소형 모바일 (max-width: 380px) */
        @media (max-width: 380px) {
            .button-group {
                flex-direction: column;
                width: 100%;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
        }
        
        /* Utility classes */
        .hidden {
            display: none !important;
        }
        
        /* 토스트 메시지 - 컴팩트 스타일 */
        .toast {
            position: fixed !important;
            top: 16px !important;
            right: 16px !important;
            background: rgba(20, 20, 25, 0.95) !important;
            backdrop-filter: blur(10px) !important;
            color: white !important;
            padding: 10px 16px !important;
            border-radius: 12px !important;
            font-size: 0.8rem !important;
            font-weight: 500 !important;
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 10000 !important;
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.1) !important;
            pointer-events: none;
            display: none;
            align-items: center;
            gap: 8px;
            max-width: 320px !important;
            min-height: 40px !important;
            width: auto !important;
            height: auto !important;
        }

        .toast.show {
            display: flex !important;
            opacity: 1 !important;
            transform: translateX(0) !important;
            pointer-events: auto;
        }
        
        .toast::before {
            content: '';
            width: 3px;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            border-radius: 12px 0 0 12px;
        }
        
        .toast[style*="16, 185, 129"]::before {
            background: #10b981;
        }
        
        .toast[style*="239, 68, 68"]::before {
            background: #ef4444;
        }
        
        .toast[style*="59, 130, 246"]::before {
            background: #3b82f6;
        }

        /* API 연동 모달 스타일 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }

        .modal-overlay.show {
            display: flex !important;
        }

        .modal-container {
            background: rgba(20, 20, 25, 0.98);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            width: 90%;
            max-width: 420px;
            max-height: 85vh;
            overflow: hidden;
            box-shadow: 
                0 0 0 1px rgba(255, 255, 255, 0.1) inset,
                0 20px 60px rgba(0, 0, 0, 0.5),
                0 0 100px rgba(168, 85, 247, 0.1);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            background: linear-gradient(135deg, rgba(168, 85, 247, 0.15) 0%, rgba(116, 75, 162, 0.15) 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .modal-close {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: all var(--transition-base);
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: white;
            transform: rotate(90deg);
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            max-height: calc(85vh - 120px);
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-select,
        .form-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 10px 14px;
            color: var(--text-primary);
            font-family: 'Paperlogy', sans-serif;
            font-size: 0.85rem;
            transition: all var(--transition-base);
        }

        .form-select:focus,
        .form-input:focus {
            outline: none;
            border-color: var(--accent-purple);
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.2);
            background: rgba(255, 255, 255, 0.08);
        }

        .form-select option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .api-info {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.08) 0%, rgba(168, 85, 247, 0.08) 100%);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .api-info a {
            color: #60a5fa;
            text-decoration: none;
            font-weight: 500;
            transition: all var(--transition-base);
        }
        
        .api-info a:hover {
            color: #93bbfc;
            text-decoration: underline;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-footer .btn {
            padding: 8px 16px;
            font-size: 0.8rem;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .btn-test {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .btn-test:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        .modal-footer .btn-save {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .modal-footer .btn-save:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .modal-footer .btn-save:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* 측면 뷰 주의사항 버튼 스타일 */
        .btn-side-view-warning {
            display: inline-flex;
            align-items: center;
            gap: 2px;
            padding: 2px 6px;
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.2) 0%, rgba(255, 152, 0, 0.2) 100%);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 4px;
            color: #ffc107;
            font-size: 0.65rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: 8px;
            font-family: 'Paperlogy', sans-serif;
            letter-spacing: 0.3px;
            text-transform: none;
            line-height: 1;
            vertical-align: middle;
        }

        .btn-side-view-warning:hover {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.3) 0%, rgba(255, 152, 0, 0.3) 100%);
            border-color: rgba(255, 193, 7, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(255, 193, 7, 0.2);
        }

        .btn-side-view-warning:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(255, 193, 7, 0.2);
        }
        
        /* 측면 뷰 모달 스타일 */
        #sideViewModal {
            display: none !important;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            animation: modalFadeIn 0.3s ease-out;
        }

        #sideViewModal.show {
            display: flex !important;
        }

        .side-view-modal {
            background: linear-gradient(135deg, rgba(20, 20, 25, 0.98) 0%, rgba(30, 30, 35, 0.98) 100%);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            padding: 0;
            width: 90%;
            max-width: 600px;
            max-height: 85vh;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
            animation: modalSlideIn 0.3s ease-out;
        }

        .side-view-modal .modal-header {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.15) 0%, rgba(255, 152, 0, 0.15) 100%);
            border-bottom: 1px solid rgba(255, 193, 7, 0.2);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .side-view-modal .modal-header h3 {
            margin: 0;
            color: #ffc107;
            font-size: 1.2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .side-view-modal .modal-close {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            line-height: 1;
        }

        .side-view-modal .modal-close:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: white;
            transform: rotate(90deg);
        }

        .side-view-modal .modal-body {
            padding: 24px;
            overflow-y: auto;
            max-height: calc(85vh - 80px);
            color: var(--text-primary);
        }

        .side-view-modal h4 {
            color: #ffc107;
            margin-bottom: 12px;
            font-size: 1rem;
            font-weight: 600;
        }

        .side-view-modal ul {
            margin-bottom: 20px;
            padding-left: 24px;
        }

        .side-view-modal li {
            margin-bottom: 8px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.8);
        }

        .side-view-modal .warning-note {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: 12px;
            padding: 16px;
            margin-top: 20px;
        }

        .side-view-modal .warning-note p {
            margin: 0;
            color: #ffc107;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        /* 최종 프롬프트 텍스트 영역 동적 높이 스타일 */
        .final-prompt-text {
            min-height: 150px;
            max-height: 80vh;
            overflow-y: auto;
            transition: height 0.3s ease;
        }

        .btn-cancel {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .btn-cancel:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.15);
            color: var(--text-primary);
        }

        .connection-status {
            margin-top: 12px;
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 0.8rem;
            display: none;
            font-weight: 500;
            text-align: center;
        }

        .connection-status.success {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.1) 100%);
            border: 1px solid rgba(16, 185, 129, 0.25);
            color: #10b981;
            display: block;
            animation: successPulse 0.3s ease-out;
        }
        
        @keyframes successPulse {
            0% { transform: scale(0.95); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .connection-status.error {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(220, 38, 38, 0.1) 100%);
            border: 1px solid rgba(239, 68, 68, 0.25);
            color: #ef4444;
            display: block;
            animation: errorShake 0.3s ease-out;
        }
        
        @keyframes errorShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        @keyframes modalFadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
    </style>
</head>
<body class="dark-theme">
    <!-- Gradient Mesh Background -->
    <div class="gradient-mesh-bg"></div>
    
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <div class="header-left">
                <a href="../index.html#features" class="home-btn">🏠 홈</a>
                <h2 class="header-title" style="font-size: 1.1rem;">이미지 프롬프트 생성기</h2>
            </div>
            <div class="header-right">
                <div class="header-buttons">
                    <a href="../storyboard/index.html" class="header-btn">스토리보드</a>
                    <a href="../concept-art/index.html" class="header-btn">컨셉아트</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast 메시지 제거됨 -->
    
    <!-- Main Container -->
    <div class="main-container">
        <!-- 요청사항 입력 섹션 -->
        <div class="section">
            <div class="section-header">
                <div class="section-header-left">
                    <h2 class="section-title">요청사항 입력</h2>
                </div>
                <button class="btn btn-primary btn-ai-connect" id="ai-connect-btn">
                    🤖 AI 연동
                </button>
            </div>


            <!-- 프롬프트 입력 영역 -->
            <div class="prompt-preview-section" style="position: relative;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm);">
                    <h3 class="preview-title">프롬프트 입력</h3>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button class="prompt-clear-btn" id="clear-prompt-btn" onclick="clearPromptInput()" title="프롬프트 초기화">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                                <path d="M21 3v5h-5"/>
                                <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                                <path d="M8 21H3v-5"/>
                            </svg>
                        </button>
                    </div>
                </div>
                <div class="prompt-preview" id="prompt-preview" contenteditable="true" spellcheck="false"></div>
            </div>

            <!-- 구조별 카드 섹션 -->
            <div class="prompt-cards-section" id="prompt-cards-section">
                <div class="cards-header">
                    <h3 class="cards-title">🎯 프롬프트 구조 편집기</h3>
                    <button class="btn btn-import" id="import-prompt-btn" onclick="importPromptFromPreview()">
                        📥 가져오기
                    </button>
                </div>
                <!-- 구조 편집기 탭 -->
                <div class="structure-tabs">
                    <div class="structure-tab-buttons">
                        <button type="button" class="structure-tab-button active" id="structure-tab-character" onclick="switchStructureTab('character')">캐릭터</button>
                        <button type="button" class="structure-tab-button" id="structure-tab-general" onclick="switchStructureTab('general')">일반이미지</button>
                    </div>
                </div>
                <div class="prompt-cards-grid" id="prompt-cards-grid">
                    <!-- 카드들이 동적으로 생성됩니다 -->
                </div>
            </div>

            <!-- 버튼 그룹 -->
            <div class="button-group">
                <button class="btn btn-primary" id="generate-prompt-btn">
                    ✨ 프롬프트 생성
                </button>
                <button class="btn btn-primary" id="ai-generate-prompt-btn" onclick="console.log('버튼 직접 클릭!'); if(window.generateAIPrompt) { window.generateAIPrompt(); } else { console.error('generateAIPrompt 함수가 아직 로드되지 않았습니다.'); }" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);">
                    🤖 AI 프롬프트 생성
                </button>
            </div>
        </div>

        <!-- 최종 프롬프트 섹션 -->
        <div class="section" id="final-prompt-section" style="display:none;">
            <div class="section-header">
                <h2 class="section-title">최종 프롬프트</h2>
            </div>
            <textarea id="final-prompt-text" class="text-input final-prompt-text" placeholder="최종 프롬프트가 여기 표시됩니다." readonly></textarea>
            <div class="button-group" style="margin-top: 8px;">
                <button class="btn copy-btn" id="copy-final-prompt-btn">📋 프롬프트 복사</button>
            </div>
        </div>
        
    </div>

    <!-- Toast Message 제거됨 -->

    <script>
        // 데이터 저장용 객체
        let promptData = {
            textInput: '',
            generatedPrompts: [],
            structuredPrompt: {}
        };

        // DOM 요소들
        const generateBtn = document.getElementById('generate-prompt-btn');
        // 기존 '생성된 프롬프트' 섹션 제거에 따라 관련 DOM 참조 삭제
        const finalPromptSection = document.getElementById('final-prompt-section');
        const finalPromptText = document.getElementById('final-prompt-text');
        const copyFinalPromptBtn = document.getElementById('copy-final-prompt-btn');
        const toast = document.getElementById('toast');
        const aiConnectBtn = document.querySelector('.btn-ai-connect');
        const promptPreview = document.getElementById('prompt-preview');
        const promptCardsSection = document.getElementById('prompt-cards-section');
        const promptCardsGrid = document.getElementById('prompt-cards-grid');
        let userEditingPreview = false;
        
        // 드롭다운 키보드 내비게이션을 위한 전역 변수
        let currentFocusedIndex = -1;
        let activeDropdown = null;



        // 프롬프트 생성
        generateBtn.addEventListener('click', async () => {
            const text = promptData.textInput || promptPreview.innerText.trim();
            
            if (!text) {
                showToast('프롬프트를 입력해주세요.', 'error');
                return;
            }

            // AI API 설정이 있으면 AI로 향상, 없으면 기존 로직 사용
            const config = localStorage.getItem('aiApiConfig');
            let prompt = '';
            
            if (config) {
                showToast('AI로 프롬프트를 향상하고 있습니다...', 'info');
                prompt = await enhancePromptWithAI(text);
            } else {
                prompt = enhancePrompt(text);
            }
            

            // 프롬프트 저장 및 표시
            promptData.generatedPrompts.push({
                timestamp: new Date().toISOString(),
                input: text,
                output: prompt
            });
            saveToLocalStorage();
            
            // 최종 프롬프트 표시 함수 호출
            displayFinalPrompt(prompt);
        });
        
        // 최종 프롬프트 표시 함수
        function displayFinalPrompt(defaultPrompt) {
            // 최종 프롬프트 섹션 업데이트: 변경반영 > 기존내용 우선으로 수집
            const resolvedStructure = { ...promptData.structuredPrompt };
            // 활성 탭의 모든 dropdown-field를 순회하여 값을 수집
            const scopeSelector = currentStructureTab === 'character' ? '.character-container' : '.general-container';
            const scope = document.querySelector(scopeSelector);
            if (scope) {
                scope.querySelectorAll('.dropdown-container').forEach(container => {
                    const key = container.dataset.key;
                    if (!key) return;
                    const appliedInput = container.querySelector(`input[data-key="${key}-applied"]`);
                    const requestInput = container.querySelector(`input[data-key="${key}-request"]`);
                    const existingInput = container.querySelector(`input[data-key="${key}"]`);
                    
                    const appliedVal = (appliedInput?.value || '').trim();
                    const requestVal = (requestInput?.value || '').trim();
                    const existingVal = (existingInput?.value || '').trim();
                    
                    // 다중값 처리: 변경반영과 변경요청을 모두 포함
                    let finalValue = '';
                    
                    // 변경반영 값이 있는 경우
                    if (appliedVal) {
                        finalValue = appliedVal;
                        
                        // 변경요청 값도 있으면 영문 부분만 추가
                        if (requestVal && requestVal !== appliedVal) {
                            // 변경요청에서 영문만 추출 (한글이 아닌 부분만)
                            const englishOnly = requestVal.split(',').map(part => part.trim())
                                .filter(part => !/[가-힣ㄱ-ㅎㅏ-ㅣ]/.test(part))
                                .join(', ');
                            
                            if (englishOnly) {
                                finalValue += ', ' + englishOnly;
                            }
                        }
                    } else if (requestVal) {
                        // 변경반영이 없고 변경요청만 있는 경우
                        finalValue = requestVal;
                    } else if (existingVal) {
                        // 둘 다 없으면 기존내용 사용
                        finalValue = existingVal;
                    }
                    
                    if (finalValue) {
                        resolvedStructure[key] = finalValue;
                    }
                });
            }
            const finalText = structureToMultilineText(resolvedStructure) || defaultPrompt || '';
            finalPromptText.value = finalText;
            finalPromptSection.style.display = 'block';
            
            // 텍스트 영역 높이 자동 조정
            autoResizeTextarea(finalPromptText);
            
            // 스크롤하여 결과 보여주기
            finalPromptSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // 예시 프롬프트 불러오기 함수
        function loadExamplePrompt() {
            const examplePrompt = `STYLE: 3D animation, Pixar/Disney style render; MEDIUM: CGI 3D animation; CAMERA: wide shot, eye level, professional studio scene; SUBJECT: stick figure character relaxing in director's chair, wearing oversized sunglasses holding whiskey glass, feet up on ottoman, confident relaxed pose; CHARACTER: simple stick figure with round head, thin black line body and limbs, comically oversized designer sunglasses, minimalist yet expressive, wearing suggested white shirt collar and dark pants through simple lines; FURNITURE: plush brown leather director's chair with rounded arms, matching ottoman footrest, luxurious vintage style; PROPS: crystal whiskey glass in stick hand, professional film cameras on tripods, C-stands with lights, reflectors, boom mics, cables on floor; AI ROBOTS: multiple cute robot assistants busily working around studio, one adjusting camera angle, another holding reflector, one operating boom mic, small wheeled robot managing cables, drone robot adjusting overhead light, all with glowing LED eyes and metallic finish; LIGHTING: dramatic studio lighting setup, warm key lights creating amber glow, cool blue fill lights for contrast, multiple light sources visible including softboxes and LED panels, professional photography setup; ENVIRONMENT: professional film studio with visible ceiling grid, white cyc wall, equipment cases, monitors showing footage, busy production atmosphere; ATMOSPHERE: humorous contrast between simple stick figure star and high-tech AI crew, behind-the-scenes movie production vibe, warm and cool color contrast; QUALITY: highly detailed 3D render, professional lighting, cinematic composition --ar 16:9 --v 6`;
            
            // 프롬프트 미리보기에 설정
            promptPreview.textContent = examplePrompt;
            promptPreview.classList.add('has-content');
            promptData.textInput = examplePrompt;
            
            // 구조화된 프롬프트로 파싱하여 카드 생성
            promptData.structuredPrompt = parsePrompt(examplePrompt);
            createPromptCards(promptData.structuredPrompt);
            promptCardsSection.style.display = 'block';
            
            // localStorage에 저장
            saveToLocalStorage();
        }

        // 프롬프트 파싱 함수 (세미콜론 기반과 줄바꿈 기반 모두 지원)
        function parsePrompt(text) {
            const structure = {};
            
            // 전체 텍스트에서 모든 파라미터 추출 (값이 있는 플래그와 단일 플래그 모두)
            const params = [];
            const paramPattern = /--[a-zA-Z0-9_-]+(?:\s+[^\s;\n]+)?/g;
            let match;
            while ((match = paramPattern.exec(text)) !== null) {
                params.push(match[0]);
            }
            
            // 파라미터를 텍스트에서 제거
            let cleanText = text;
            params.forEach(param => {
                cleanText = cleanText.replace(param, '').replace(/\s{2,}/g, ' ');
            });
            
            // 줄바꿈이 있으면 줄바꿈 기반으로, 없으면 세미콜론 기반으로 파싱
            let lines;
            if (cleanText.includes('\n')) {
                // 줄바꿈 기반 파싱
                lines = cleanText.split('\n').map(line => line.trim()).filter(line => line);
                // 각 줄에서 끝의 세미콜론 제거
                lines = lines.map(line => line.endsWith(';') ? line.slice(0, -1).trim() : line);
            } else {
                // 세미콜론 기반 파싱
                lines = cleanText.split(';').map(line => line.trim()).filter(line => line);
            }
            
            lines.forEach(line => {
                const colonIndex = line.indexOf(':');
                if (colonIndex > -1) {
                    const key = line.substring(0, colonIndex).trim();
                    const value = line.substring(colonIndex + 1).trim();
                    if (key.toUpperCase() !== 'PARAMETERS' || params.length === 0) {
                        structure[key] = value;
                    }
                }
            });
            
            // 파라미터 저장 (있을 때만)
            if (params.length > 0) {
                structure['PARAMETERS'] = params.join(' ');
            }
            
            return structure;
        }

        // 프롬프트 향상 함수
        function enhancePrompt(text) {
            // 구조화된 프롬프트인지 확인
            if (text.includes(':') && text.includes(';')) {
                return text; // 이미 구조화된 프롬프트는 그대로 반환
            }
            
            // 기본 향상 키워드
            const enhancements = {
                quality: 'highly detailed, 4k, professional',
                style: 'cinematic lighting, photorealistic',
                camera: 'rule of thirds composition',
            };

            let enhanced = text;
            
            // 품질 관련 키워드가 없으면 추가
            if (!text.toLowerCase().includes('detailed') && !text.toLowerCase().includes('quality')) {
                enhanced += ', ' + enhancements.quality;
            }

            return enhanced;
        }

        // 구조화된 프롬프트를 텍스트로 변환
        function structureToText(structure) {
            let text = '';
            const params = structure['PARAMETERS'] || '';
            const keys = Object.keys(structure).filter(key => key !== 'PARAMETERS');
            
            keys.forEach((key, index) => {
                if (structure[key]) { // 값이 있는 경우만 추가
                    text += `${key}: ${structure[key]}`;
                    if (index < keys.length - 1) {
                        text += '; ';
                    }
                }
            });
            
            if (params) {
                text += ` PARAMETERS: ${params}`;
            }
            
            return text;
        }

        // 구조화된 프롬프트를 보기 좋게 줄바꿈된 텍스트로 변환
        function structureToMultilineText(structure) {
            const lines = [];
            const params = structure['PARAMETERS'] || '';
            const keys = Object.keys(structure).filter(key => key !== 'PARAMETERS');
            keys.forEach(key => {
                if (structure[key]) {
                    lines.push(`${key}: ${structure[key]};`);
                }
            });
            if (params) {
                lines.push(`PARAMETERS: ${params}`);
            }
            return lines.join('\n');
        }

        // 현재 활성화된 구조 탭
        let currentStructureTab = 'character';
        
        // 구조 탭 전환 함수
        function switchStructureTab(tab) {
            currentStructureTab = tab;
            document.getElementById('structure-tab-character').classList.toggle('active', tab === 'character');
            document.getElementById('structure-tab-general').classList.toggle('active', tab === 'general');
            
            // 현재 프롬프트 데이터로 카드 재생성
            if (Object.keys(promptData.structuredPrompt).length > 0) {
                createPromptCards(promptData.structuredPrompt);
            }
        }
        
        // 캐릭터 하위 탭 전환 함수
        function switchCharacterSubTab(categoryIndex) {
            // 캐릭터 탭 내에서만 작동하도록 범위 제한
            const characterContainer = document.querySelector('.character-container');
            if (!characterContainer) return;
            
            // 모든 하위 탭 버튼의 active 클래스 제거
            characterContainer.querySelectorAll('.sub-tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 클릭된 탭 버튼에 active 클래스 추가
            characterContainer.querySelector(`.sub-tab-button[data-category="${categoryIndex}"]`)?.classList.add('active');
            
            // 모든 컨텐츠 숨김
            characterContainer.querySelectorAll('.sub-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 선택된 컨텐츠만 표시
            characterContainer.querySelector(`.sub-tab-content[data-category="${categoryIndex}"]`)?.classList.add('active');
        }
        
        // 일반 하위 탭 전환 함수
        function switchGeneralSubTab(categoryIndex) {
            // 일반 탭 내에서만 작동하도록 범위 제한
            const generalContainer = document.querySelector('.general-container');
            if (!generalContainer) return;
            
            // 모든 하위 탭 버튼의 active 클래스 제거
            generalContainer.querySelectorAll('.sub-tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 클릭된 탭 버튼에 active 클래스 추가
            generalContainer.querySelector(`.sub-tab-button[data-category="${categoryIndex}"]`)?.classList.add('active');
            
            // 모든 컨텐츠 숨김
            generalContainer.querySelectorAll('.sub-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 선택된 컨텐츠만 표시
            generalContainer.querySelector(`.sub-tab-content[data-category="${categoryIndex}"]`)?.classList.add('active');
        }
        
        // 카드 생성 함수
        function createPromptCards(structure) {
            promptCardsGrid.innerHTML = '';
            
            // 캐릭터 탭 카테고리 (이미지 기준)
            // 스타일 옵션 목록
        // 스타일 옵션 목록 (2025 Midjourney v7 최신 업데이트)
        const styleOptions = [
            "Abstract (추상)", 
            "Aerial (항공)", 
            "Analog (아날로그)", 
            "Animated (애니메이션)", 
            "Architectural Photography (건축 사진)", 
            "Art Deco (아르데코)", 
            "Art Nouveau (아르누보)", 
            "Baroque (바로크)", 
            "Bauhaus (바우하우스)", 
            "Blobitecture (블로비텍처)", 
            "Brutalism (브루탈리즘)", 
            "Comic Book (만화책)", 
            "Collage (콜라주)", 
            "Concept Art (컨셉 아트)", 
            "Cottagecore (코티지코어)", 
            "Cubism (큐비즘)", 
            "Cyberpunk (사이버펑크)", 
            "Dadaism (다다이즘)", 
            "Dark Academia (다크 아카데미아)", 
            "Dark Fantasy (다크 판타지)", 
            "Disney Style (디즈니 스타일)", 
            "Documentary (다큐멘터리)", 
            "Double Exposure (이중 노출)", 
            "Dreamcore (드림코어)", 
            "Expressionism (표현주의)", 
            "Fantasy (판타지)", 
            "Fantasy Illustration (판타지 일러스트레이션)", 
            "Fashion Photography (패션 사진)", 
            "Fauvism (포비즘)", 
            "Film Noir (필름 느와르)", 
            "Food Photography (푸드 사진)", 
            "Fresco (프레스코)", 
            "Glitchcore (글리치코어)", 
            "Gothic (고딕)", 
            "Graphic Novel (그래픽 노블)", 
            "Horror (공포)", 
            "Hyper-Detailed (하이퍼디테일)", 
            "Hyperrealism (하이퍼리얼리즘)", 
            "Impressionism (인상주의)", 
            "Isometric (아이소메트릭)", 
            "Landscape (풍경)", 
            "Liminal Space (리미널 스페이스)", 
            "Line Art (라인 아트)", 
            "Low Poly (로우 폴리)", 
            "Macro Photography (매크로 사진)", 
            "Manga (망가)", 
            "McBling (McBling)", 
            "Minimalism (미니멀리즘)", 
            "Neo-Expressionism (네오 표현주의)", 
            "Neon Art (네온 아트)", 
            "Night Photography (야간 사진)", 
            "Nostalgiacore (노스탤지어코어)", 
            "Paper Illustration (종이 일러스트레이션)", 
            "Photorealism (포토리얼리즘)", 
            "Pixar (픽사)", 
            "Pixel Art (픽셀 아트)", 
            "Pointillism (점묘법)", 
            "Pop Art (팝 아트)", 
            "Portrait (초상화)", 
            "Psychedelic (사이키델릭)", 
            "Renaissance (르네상스)", 
            "Retro (레트로)", 
            "Retro Futurism (레트로 퓨처리즘)", 
            "Rococo (로코코)", 
            "Romanticism (낭만주의)", 
            "Sketch Style (스케치 스타일)", 
            "Stained Glass (스테인드글라스)", 
            "Steampunk (스팀펑크)", 
            "Still Life (정물화)", 
            "Street Photography (스트리트 사진)", 
            "Studio Ghibli (스튜디오 지브리)", 
            "Suprematism (절대주의)", 
            "Surrealism (초현실주의)", 
            "Symbolism (상징주의)", 
            "Synthwave (신스웨이브)", 
            "Technical Drawing (기술 도면)", 
            "Tempera (템페라)", 
            "Traumacore (트라우마코어)", 
            "Vaporwave (베이퍼웨이브)", 
            "Voxel Art (복셀 아트)", 
            "Webcore (웹코어)", 
            "Weirdcore (위어드코어)", 
            "Whimsical (기발한)", 
            "Y2K Aesthetic (Y2K 미학)"
        ];

        // 각 섹션별 드롭다운 옵션
        const dropdownOptions = {
            STYLE: styleOptions,
            MEDIUM: [
                "Photography (사진)",
                "3D Modeling (3D 모델링)",
                "Acrylic Painting (아크릴화)",
                "Animation (애니메이션)",
                "Concept Art (컨셉 아트)",
                "Digital Art (디지털 아트)",
                "Illustration (일러스트레이션)",
                "Manga (만화)",
                "Oil Painting (유화)",
                "Painting (회화)",
                "Pencil Sketch (연필 스케치)",
                "Sketch (스케치)",
                "Typography (타이포그래피)",
                "Vector Graphics (벡터 그래픽)",
                "Watercolor (수채화)",
                "Ballpoint Pen Sketch (볼펜 스케치)",
                "Chalk Art (분필 아트)",
                "Charcoal Drawing (목탄화)",
                "Colored Pencil (색연필)",
                "Conte (콩테)",
                "Encaustic Painting (왁스화)",
                "Fresco (프레스코화)",
                "Gouache Painting (과슈화)",
                "Ink Drawing (잉크 드로잉)",
                "Line Art (라인 아트)",
                "Marker Art (마커 아트)",
                "Pastel Drawing (파스텔화)",
                "Pen and Ink (펜과 잉크)",
                "Stippling (점묘화)",
                "Sumi-e (수묵화)",
                "Block Print (블록 프린트)",
                "Calligraphy (캘리그래피)",
                "Cyanotype (청사진 인화)",
                "Etching (에칭)",
                "Linocut (리노컷)",
                "Lithography (석판화)",
                "Poster Design (포스터 디자인)",
                "Risograph (리소그래프)",
                "Screen Printing (실크스크린 인쇄)",
                "Woodcut (목판화)",
                "Acrylic Pour (아크릴 붓기)",
                "Airbrush (에어브러시)",
                "Augmented Reality Art (증강현실 아트)",
                "Blacklight Painting (블랙라이트 페인팅)",
                "Collage (콜라주)",
                "Comic Art (만화 아트)",
                "Futuristic Digital (미래지향 디지털)",
                "Generative Art (생성 아트)",
                "Glitch Art (글리치 아트)",
                "Graffiti (그래피티)",
                "Holography (홀로그래피)",
                "Isometric Art (아이소메트릭 아트)",
                "Mixed Media (믹스드 미디어)",
                "Neon Art (네온 아트)",
                "Pixel Art (픽셀 아트)",
                "Sci-Fi Art (SF 아트)",
                "Spray Paint (스프레이 페인팅)",
                "Stencil Art (스텐실 아트)",
                "Street Art (스트리트 아트)",
                "Batik (바틱)",
                "Calligraphy (서예)",
                "Cross Stitch (십자수)",
                "Crochet (코바늘뜨기)",
                "Embroidery (자수)",
                "Mosaic (모자이크)",
                "Origami (종이접기)",
                "Paint by Numbers (페인트 바이 넘버)",
                "Pointillism (점묘화)",
                "Pressed Flower (압화)",
                "Quilling (퀼링)",
                "Sculpture (조각)",
                "Textile Art (섬유 예술)",
                "Ukiyo-e (우키요에)"
            ],
            'ERA/CULTURAL_REF': [
                "Age of Exploration (대항해시대)",
                "American Revolution (미국 독립 전쟁)",
                "Crusade (십자군 전쟁)",
                "Fall of the Roman Empire (로마 제국의 몰락)",
                "French Revolution (프랑스 혁명)",
                "Goryeo-Khitan War (고려-거란 전쟁)",
                "Hundred Years' War (백년전쟁)",
                "Industrial Revolution (산업 혁명)",
                "Mongol Empire Conquests (몽골 제국의 정복)",
                "Napoleonic Wars (나폴레옹 전쟁)",
                "Native Americans and Colonization (아메리카 원주민과 식민화)",
                "Renaissance era (르네상스 시대)",
                "Russian Revolution (러시아 혁명)",
                "Saigong the Great Era (세종대왕 시대)",
                "Vietnam War (베트남 전쟁)",
                "Warring States Period (전국 시대)",
                "World War I (제1차 세계 대전)",
                "World War II (제2차 세계 대전)"
            ],
            SCENE: [],
            COLOR_TONE: [
                "amber tones (호박색 톤)",
                "amethyst colors (애수정라이트 색상)",
                "azure (하늘색)",
                "blue dominant (파란 위주)",
                "blood red (블러드 레드)",
                "bright highlights (밝은 하이라이트)",
                "brightly colored (밝게 채색됨)",
                "chrome colors (크롬 색상)",
                "chromatic color grading (색채학적 색보정)",
                "complementary colors (보색)",
                "cool blue tones (차가운 파란 톤)",
                "cool colors (차가운 색상)",
                "dark colors (어두운 색상)",
                "deep shadows (깊은 그림자)",
                "desaturated colors (채도가 낮은 색상)",
                "duotone colors (듀오톤 색상)",
                "earthy tones (자연스러운 톤)",
                "fiery colors (불같은 색상)",
                "fluorescent colors (형광 색상)",
                "golden tones (황금색 톤)",
                "gradient colors (그레이디언트 색상)",
                "greyscale (그레이스케일)",
                "green dominant (초록 위주)",
                "high contrast (고대비)",
                "iridescent colors (무지개빛 색상)",
                "jade tones (옥색 톤)",
                "low contrast (저대비)",
                "luminous colors (발광 색상)",
                "metallic colors (메탈릭 색상)",
                "monochrome colors (단색)",
                "muted colors (차분한 색상)",
                "neon colors (네온 색상)",
                "pastel colors (파스텔 색상)",
                "pearlescent colors (진주빛 색상)",
                "pink tones (분홍 톤)",
                "primary colors (원색)",
                "psychedelic colors (사이키델릭 색상)",
                "purple tones (보라 톤)",
                "red dominant (빨간 위주)",
                "saturated colors (채도 높은 색상)",
                "sepia (세피아)",
                "silver tones (은빛 톤)",
                "subdued tones (차분한 톤)",
                "teal tones (청록 톤)",
                "translucent colors (반투명 색상)",
                "vibrant colors (선명한 색상 (강한 색상))",
                "vintage color grading (빈티지 색보정)",
                "vivid colors (선명한 색상)",
                "warm orange tones (따뜻한 주황 톤)"
            ],
            CHARACTER: [
                "Korean male child (한국 남자 어린이)",
                "Korean female child (한국 여자 어린이)",
                "Korean male teen (한국 남자 청소년)",
                "Korean female teen (한국 여자 청소년)",
                "Korean male 20s (한국 남자 20대)",
                "Korean female 20s (한국 여자 20대)",
                "Korean male 30s (한국 남자 30대)",
                "Korean female 30s (한국 여자 30대)",
                "Korean male 40s (한국 남자 40대)",
                "Korean female 40s (한국 여자 40대)",
                "Korean male 50s (한국 남자 50대)",
                "Korean female 50s (한국 여자 50대)",
                "Korean male 60s (한국 남자 60대)",
                "Korean female 60s (한국 여자 60대)",
                "Korean male 70s+ (한국 남자 70대 이상)",
                "Korean female 70s+ (한국 여자 70대 이상)",
                "Japanese male teen (일본 남자 청소년)",
                "Japanese female teen (일본 여자 청소년)",
                "Japanese male 20s (일본 남자 20대)",
                "Japanese female 20s (일본 여자 20대)",
                "Japanese male 30s (일본 남자 30대)",
                "Japanese female 30s (일본 여자 30대)",
                "Japanese male 40s (일본 남자 40대)",
                "Japanese female 40s (일본 여자 40대)",
                "Chinese male 20s (중국 남자 20대)",
                "Chinese female 20s (중국 여자 20대)",
                "Chinese male 30s (중국 남자 30대)",
                "Chinese female 30s (중국 여자 30대)",
                "Chinese male 40s (중국 남자 40대)",
                "Chinese female 40s (중국 여자 40대)",
                "American male teen (미국 남자 청소년)",
                "American female teen (미국 여자 청소년)",
                "American male 20s (미국 남자 20대)",
                "American female 20s (미국 여자 20대)",
                "American male 30s (미국 남자 30대)",
                "American female 30s (미국 여자 30대)",
                "American male 40s (미국 남자 40대)",
                "American female 40s (미국 여자 40대)",
                "American male 50s (미국 남자 50대)",
                "American female 50s (미국 여자 50대)",
                "European male 20s (유럽 남자 20대)",
                "European female 20s (유럽 여자 20대)",
                "European male 30s (유럽 남자 30대)",
                "European female 30s (유럽 여자 30대)",
                "European male 40s (유럽 남자 40대)",
                "European female 40s (유럽 여자 40대)",
                "British male 30s (영국 남자 30대)",
                "British female 30s (영국 여자 30대)",
                "French male 30s (프랑스 남자 30대)",
                "French female 30s (프랑스 여자 30대)",
                "German male 30s (독일 남자 30대)",
                "German female 30s (독일 여자 30대)",
                "Italian male 30s (이탈리아 남자 30대)",
                "Italian female 30s (이탈리아 여자 30대)",
                "Indian male 20s (인도 남자 20대)",
                "Indian female 20s (인도 여자 20대)",
                "Indian male 30s (인도 남자 30대)",
                "Indian female 30s (인도 여자 30대)",
                "Southeast Asian male 20s (동남아시아 남자 20대)",
                "Southeast Asian female 20s (동남아시아 여자 20대)",
                "Southeast Asian male 30s (동남아시아 남자 30대)",
                "Southeast Asian female 30s (동남아시아 여자 30대)",
                "Latin American male 20s (라틴 아메리카 남자 20대)",
                "Latin American female 20s (라틴 아메리카 여자 20대)",
                "Latin American male 30s (라틴 아메리카 남자 30대)",
                "Latin American female 30s (라틴 아메리카 여자 30대)",
                "Middle Eastern male 30s (중동 남자 30대)",
                "Middle Eastern female 30s (중동 여자 30대)",
                "African male 20s (아프리카 남자 20대)",
                "African female 20s (아프리카 여자 20대)",
                "African male 30s (아프리카 남자 30대)",
                "African female 30s (아프리카 여자 30대)"
            ],
            CHARACTER_SHEET: [
                "character turnaround sheet, multiple views, same character, front view and face close-up, same character, detailed view (입체스트 전신)",
                "photo collage of same person, multiple angles, front portrait, side profile, three-quarter view, consistent person (사진전신)",
                "character face sheet, close-up portraits, same character, front face, side profile, 3/4 angle, facial details (입체스트 얼굴)",
                "photo collage of same person's face, close-up shots, front portrait, side profile, three-quarter view, consistent face (사진 얼굴)",
                "character reference sheet, full body shot and portrait close-up, same character, detailed view (입체스트 혼합)",
                "photo reference of same person, full body shot and portrait close-up, consistent person, detailed views (사진 혼합)",
                "character expression sheet, multiple emotions close-up, same character, face happy, sad, angry, surprised, neutral expressions (입체스트 표정 클로즈업)",
                "photo collage of facial expressions, close-up emotions, same person, smiling, crying, laughing, serious, thoughtful faces (사진 표정 클로즈업)",
                "character emotion sheet, full body expressions and poses, same character, happy pose, sad pose, excited pose, tired pose (입체스트 표정 전신)",
                "photo series showing emotions, full body shots, same person, joyful stance, dejected posture, energetic pose, relaxed position (사진 표정 전신)",
                "character reference emotions, full body and face expressions, same character, detailed emotional range (입체스트 표정 혼합)",
                "photo emotion reference sheet, portrait and full body, emotional states, same person, comprehensive mood variations (사진 표정 혼합)"
            ],
            BODY_TYPE: [
                "slim build (마른 체형)",
                "average figure (보통 체형)",
                "thin physique (가는 체격)",
                "petite frame (아담한 체격)",
                "small build (작은 체격)",
                "average build (평균 체형)",
                "medium build (중간 체형)",
                "athletic build (운동선수 체형)",
                "fit physique (탄탄한 체격)",
                "toned body (탄탄있는 몸)",
                "muscular frame (근육질 체격)",
                "strong build (건장한 체형)",
                "stocky build (땅딸막한 체형)",
                "broad shoulders (넓은 어깨)",
                "curvy figure (곡선이 있는 체형)",
                "hourglass figure (모래시계 몸매)",
                "pear-shaped body (배 모양 체형)",
                "plus size (플러스 사이즈)",
                "full figure (풍만한 체형)",
                "heavyset build (육중한 체형)",
                "tall and slim (키크고 마른)",
                "tall and athletic (키크고 운동선수같은)",
                "short and petite (작고 아담한)",
                "short and stocky (작고 단단한)",
                "lanky build (호리호리한 체형)",
                "lean physique (군살없는 체형)",
                "robust build (튼튼한 체형)",
                "delicate frame (섬세한 체형)",
                "sturdy build (튼튼한 체형)",
                "compact build (다부진 체형)",
                "150cm tall (150cm 키)",
                "160cm tall (160cm 키)",
                "170cm tall (170cm 키)",
                "180cm tall (180cm 키)",
                "190cm tall (190cm 키)",
                "child body type (어린아이 체형)",
                "teenage body type (청소년 체형)",
                "mature body type (성인 체형)",
                "elderly physique (노인 체형)",
                "pregnant figure (임산부 체형)"
            ],
            HAIR: [
                "short hair (짧은 머리)",
                "medium length hair (중간 길이 머리)",
                "long hair (긴 머리)",
                "very long hair (아주 긴 머리)",
                "shoulder length hair (어깨 길이 머리)",
                "pixie cut (픽시컷)",
                "bob cut (단발머리)",
                "lob cut (롱 단발)",
                "layered hair (레이어드 헤어)",
                "straight hair (직모)",
                "wavy hair (웨이브 머리)",
                "curly hair (곱슬머리)",
                "kinky hair (꼬불꼬불 머리)",
                "afro hair (아프로 헤어)",
                "side part (옆 가르마)",
                "center part (중앙 가르마)",
                "middle part (가운데 가르마)",
                "messy hair (헝클어진 머리)",
                "tousled hair (부스스한 머리)",
                "neat hair (단정한 머리)",
                "ponytail (포니테일)",
                "high ponytail (높은 포니테일)",
                "low ponytail (낮은 포니테일)",
                "pigtails (양갈래 머리)",
                "braided hair (땋은 머리)",
                "french braid (프렌치 브레이드)",
                "side braid (옆으로 땋은 머리)",
                "fishtail braid (피쉬테일)",
                "top knot (탑 노트)",
                "messy bun (헝클어진 번)",
                "space buns (스페이스 번)",
                "undercut (언더컷)",
                "side swept hair (옆으로 넘긴 머리)",
                "bangs (앞머리)",
                "side bangs (옆 앞머리)",
                "curtain bangs (커튼 앞머리)",
                "blunt bangs (일자 앞머리)",
                "mohawk (모히칸)",
                "dreadlocks (드레드락)",
                "cornrows (콘로우)",
                "buzz cut (빡빡머리)",
                "bald (대머리)",
                "shaved head (민둥머리)",
                "brown hair (갈색 머리)",
                "blonde hair (금발 머리)",
                "red hair (빨간 머리)",
                "black hair (검은 머리)",
                "gray hair (회색 머리)",
                "silver hair (은발)",
                "white hair (백발)",
                "platinum blonde (플래티넘 블론드)",
                "ombre hair (옴브레 헤어)",
                "highlighted hair (하이라이트 헤어)",
                "two-toned hair (투톤 헤어)",
                "rainbow hair (무지개 색 머리)",
                "shiny hair (윤기나는 머리)",
                "matte hair (매트한 머리)",
                "silky hair (실키한 머리)",
                "thick hair (두꺼운 머리)",
                "thin hair (얇은 머리)",
                "voluminous hair (볼륨있는 머리)"
            ],
            FACE_SHAPE: [
                "oval face (계란형 얼굴)",
                "round face (둥근 얼굴)",
                "square face (사각형 얼굴)",
                "heart face (하트형 얼굴)",
                "diamond face (다이아몬드형 얼굴)",
                "oblong face (직사각형 얼굴)",
                "inverted triangle face (역삼각형 얼굴)",
                "rectangular face (직사각형 얼굴)",
                "long face (긴 얼굴)",
                "narrow face (좁은 얼굴)",
                "wide face (넓은 얼굴)",
                "small face (작은 얼굴)",
                "delicate face (섬세한 얼굴)",
                "angular face (각진 얼굴)",
                "soft features (부드러운 이목구비)",
                "sharp features (날카로운 이목구비)",
                "defined jawline (뚜렷한 턱선)",
                "soft jawline (부드러운 턱선)",
                "strong jawline (강한 턱선)",
                "pointed chin (뾰족한 턱)",
                "rounded chin (둥근 턱)",
                "square jaw (사각 턱)",
                "v-line face (브이라인 얼굴)",
                "chubby cheeks (통통한 볼)",
                "hollow cheeks (홀쭉한 볼)",
                "high cheekbones (높은 광대뼈)",
                "prominent cheekbones (도드라진 광대뼈)",
                "flat cheekbones (평평한 광대뼈)",
                "sunken cheeks (꺼진 볼)",
                "slim face (가름한 얼굴)",
                "gaunt face (수척한 얼굴)",
                "full face (통통한 얼굴)",
                "baby face (동안)",
                "mature face (성숙한 얼굴)",
                "symmetrical face (대칭적인 얼굴)",
                "asymmetrical face (비대칭 얼굴)"
            ],
            FACIAL_FEATURES: [
                "almond eyes (아몬드형 눈)",
                "round eyes (둥근 눈)",
                "narrow eyes (가는 눈)",
                "wide eyes (큰 눈)",
                "deep-set eyes (깊이 들어간 눈)",
                "protruding eyes (튀어나온 눈)",
                "hooded eyes (처진 눈꺼풀)",
                "monolid eyes (홑꺼풀)",
                "double eyelids (쌍꺼풀)",
                "upturned eyes (위로 올라간 눈)",
                "downturned eyes (아래로 처진 눈)",
                "close-set eyes (가까운 눈)",
                "wide-set eyes (멀리 떨어진 눈)",
                "straight eyebrows (일자 눈썹)",
                "arched eyebrows (아치형 눈썹)",
                "thick eyebrows (진한 눈썹)",
                "thin eyebrows (얇은 눈썹)",
                "bushy eyebrows (덤불같은 눈썹)",
                "groomed eyebrows (다듬은 눈썹)",
                "straight nose (곧은 코)",
                "button nose (단추 코)",
                "aquiline nose (매부리코)",
                "upturned nose (들린 코)",
                "flat nose (낮은 코)",
                "wide nose (넓은 코)",
                "narrow nose (좁은 코)",
                "long nose (긴 코)",
                "small nose (작은 코)",
                "prominent nose (돌출된 코)",
                "full lips (두툼한 입술)",
                "thin lips (얇은 입술)",
                "heart-shaped lips (하트 모양 입술)",
                "wide mouth (넓은 입)",
                "small mouth (작은 입)",
                "plump lips (통통한 입술)",
                "curved lips (곡선형 입술)",
                "long eyelashes (긴 속눈썹)",
                "thick eyelashes (짙은 속눈썹)",
                "sparse eyelashes (듬성듬성 속눈썹)",
                "high forehead (높은 이마)",
                "low forehead (낮은 이마)",
                "broad forehead (넓은 이마)",
                "narrow forehead (좁은 이마)",
                "dimples (보조개)",
                "freckles (주근깨)",
                "beauty mark (점)",
                "mole (점)",
                "bear complexion (베어 피부톤)",
                "clear complexion (맑은 피부)",
                "wrinkles (주름)",
                "laugh lines (웃음 주름)",
                "frown lines (눈살 주름)",
                "nose bridge (콧대)",
                "aquiline nose profile (측면형)매부리코 측면 얼굴임)",
                "straight nose profile (측면형)곧은 코 얼굴임)",
                "button nose profile (측면형)들린 코 얼굴임)",
                "defined jawline (측면형)뚜렷한 턱선)",
                "strong lips profile (측면형)강한 입술 턱)",
                "receding chin (측면형)뒤로 빠진 턱)",
                "protruding lips (측면형)튀어 나온 입술)",
                "lip profile (측면형)입술 옆모습)",
                "waffle-like cheek (측면형)격자 무늬형 볼)",
                "Adam's apple (측면형)목젖(아담의 사과))",
                "defined eye area (측면형)뚜렷한 눈 모양)",
                "eye shape (측면형)눈 모양)",
                "cheekbone profile (측면형)광대뼈 옆모습 윤곽)",
                "forehead slope (측면형)이마 경사)",
                "nose bridge profile (측면형)코다리 옆모습)",
                "facial contour (측면형)얼굴 윤곽)",
                "head shape (측면형)머리 모양)"
            ],
            SKIN: [
                "pale skin (창백한 피부)",
                "fair skin (하얀 피부)",
                "light skin (밝은 피부)",
                "medium skin (중간톤 피부)",
                "olive skin (올리브색 피부)",
                "tan skin (구릿빛 피부)",
                "dark skin (어두운 피부)",
                "warm skin (따뜻한 피부톤)",
                "cool skin (차가운 피부톤)",
                "porcelain skin (도자기같은 피부)",
                "ebony skin (흑단같은 피부)",
                "beige skin (베이지색 피부)",
                "golden skin (황금빛 피부)",
                "bronze skin (브론즈색 피부)",
                "honey skin (꿀색 피부)",
                "caramel skin (캐러멜색 피부)",
                "smooth skin (매끄러운 피부)",
                "soft skin (부드러운 피부)",
                "rough skin (거친 피부)",
                "flawless skin (흠잡을 데 없는 피부)",
                "clear skin (맑은 피부)",
                "flawless skin (완벽한 피부)",
                "glowing skin (빛나는 피부)",
                "dewy skin (촉촉한 피부)",
                "matte skin (매트한 피부)",
                "oily skin (기름진 피부)",
                "dry skin (건조한 피부)",
                "freckled skin (주근깨 있는 피부)",
                "spotted skin (점이 있는 피부)",
                "wrinkled skin (주름진 피부)",
                "aged skin (노화된 피부)",
                "youthful skin (젊은 피부)",
                "radiant skin (빛나는 피부)",
                "sun-kissed skin (햇볕에 그을린 피부)",
                "weathered skin (풍화된 피부)",
                "sunburned skin (햇볕에 탄 피부)",
                "tattooed skin (문신이 있는 피부)",
                "natural skin (자연스러운 피부)",
                "airbrushed skin (에어브러시된 피부)",
                "textured skin (질감있는 피부)",
                "translucent skin (반투명한 피부)",
                "girl skin (여자 피부)",
                "boy skin (남자 피부)"
            ],
            EXPRESSION: [
                "neutral expression (무표정)",
                "calm expression (차분한 표정)",
                "serene expression (고요한 표정)",
                "bright smile (밝은 미소)",
                "gentle smile (부드러운 미소)",
                "warm smile (따뜻한 미소)",
                "big smile (활짝 웃음)",
                "laughing (웃고 있는)",
                "grinning (씨익 웃는)",
                "smirking (비웃듯)",
                "slight smile (살짝 미소)",
                "sad expression (슬픈 표정)",
                "crying (울고 있는)",
                "tearful (눈물어린)",
                "melancholic look (우울한 표정)",
                "disappointed (실망한)",
                "angry expression (화난 표정)",
                "furious (격노한)",
                "annoyed (짜증난)",
                "frowning (찌푸린)",
                "scowling (노려보는)",
                "surprised expression (놀란 표정)",
                "shocked (충격받은)",
                "wide-eyed (눈이 휘둥그레진)",
                "amazed (경탄하는)",
                "confused (혼란스러운)",
                "puzzled (어리둥절한)",
                "thoughtful (생각에 잠긴)",
                "contemplative (사색적인)",
                "focused (집중하는)",
                "determined (단호한)",
                "confident (자신감 있는)",
                "proud (자부심 있는)",
                "shy expression (수줍은 표정)",
                "embarrassed (당황한)",
                "blushing (홍조 띤(얼굴))",
                "nervous (긴장한)",
                "anxious (불안한)",
                "worried (걱정스러운)",
                "fearful (두려운)",
                "terrified (겁에 질린)",
                "disgusted (역겨워하는)",
                "contemptuous (경멸하는)",
                "bored expression (지루한 표정)",
                "tired (피곤한)",
                "sleepy (졸린)",
                "exhausted (지친)",
                "relaxed (편안한)",
                "content (만족한)",
                "joyful (즐거운)",
                "excited (신난)",
                "enthusiastic (열정적인)",
                "playful (장난스러운)",
                "mischievous (짓궂은)",
                "seductive (유혹적인)",
                "flirtatious (시시덕거리는)",
                "serious expression (진지한 표정)",
                "stern (엄격한)",
                "grim (우울한)",
                "intense gaze (강렬한 시선)",
                "stoic (무뚝뚝한)",
                "fierce gaze (맹렬한 시선)"
            ],
            GAZE: [
                "looking at camera (카메라를 보는)",
                "looking straight ahead (정면을 보는)",
                "looking at viewer (관람자를 보는)",
                "direct eye contact (직접적인 눈맞춤)",
                "looking away (다른 곳을 보는)",
                "looking to the side (옆을 보는)",
                "looking up (위를 올려다보는)",
                "looking right (오른쪽을 보는)",
                "looking left (왼쪽을 보는)",
                "looking down (아래를 내려다보는)",
                "looking over shoulder (어깨 너머로 보는)",
                "looking back (뒤를 돌아보는)",
                "eyes closed (눈을 감은)",
                "eyes half closed (눈을 반쯤 감은)",
                "one eye closed (한쪽 눈을 감은)",
                "gazing into distance (먼 곳을 응시하는)",
                "staring ahead (앞을 응시하는)",
                "vacant stare (공허한 시선)",
                "dreamy gaze (몽환적인 시선)",
                "intense stare (강렬한 응시)",
                "piercing gaze (날카로운 시선)",
                "shy gaze (부끄러운 시선)",
                "soft gaze (부드러운 시선)",
                "focused gaze (집중된 시선)",
                "sideways glance (옆눈질)",
                "averted eyes (피하는 시선)",
                "upward glance (위를 흘끗 보는)",
                "downcast eyes (깔은 눈 시선)",
                "unfocused eyes (초점 없는 눈)",
                "contemplative gaze (사색적인 시선)",
                "seductive gaze (유혹적인 시선)",
                "suspicious glance (의심스러운 눈초리)",
                "curious gaze (호기심 어린 시선)",
                "defiant stare (반항적인 응시)",
                "longing gaze (갈망하는 시선)",
                "tearful eyes (눈물 어린 눈)",
                "confident gaze (자신감 있는 시선)",
                "shy glance (수줍은 눈빛)",
                "tired eyes (피곤한 눈빛)",
                "winking (윙크하는)"
            ],
            CLOTHING: [
                "t-shirt (티셔츠)",
                "plain t-shirt (무지 티셔츠)",
                "graphic t-shirt (그래픽 티셔츠)",
                "polo shirt (폴로셔츠)",
                "dress shirt (드레스 셔츠)",
                "button-up shirt (버튼업 셔츠)",
                "blouse (블라우스)",
                "tank top (탱크탑)",
                "crop top (크롭탑)",
                "sweater (스웨터)",
                "hoodie (후드티)",
                "sweatshirt (맨투맨)",
                "cardigan (가디건)",
                "jacket (재킷)",
                "blazer (블레이저)",
                "leather jacket (가죽 재킷)",
                "denim jacket (데님 재킷)",
                "bomber jacket (봄버 재킷)",
                "suit (정장)",
                "tuxedo (턱시도)",
                "french coat (트렌치 코트)",
                "winter coat (겨울 코트)",
                "parka (파카)",
                "vest (조끼)",
                "jeans (청바지)",
                "denim pants (데님 팬츠)",
                "trousers (바지)",
                "slacks (슬랙스)",
                "chinos (치노 팬츠)",
                "shorts (반바지)",
                "cargo pants (카고 팬츠)",
                "leggings (레깅스)",
                "skirt (치마)",
                "mini skirt (미니스커트)",
                "midi skirt (미디스커트)",
                "long skirt (롱스커트)",
                "pleated skirt (플리츠 스커트)",
                "pencil skirt (펜슬 스커트)",
                "a-line skirt (에이라인 스커트)",
                "wrap skirt (랩 스커트)",
                "casual dress (캐주얼 원피스)",
                "formal dress (정장 원피스)",
                "evening gown (이브닝 가운)",
                "cocktail dress (칵테일 드레스)",
                "sundress (선드레스)",
                "maxi dress (맥시 드레스)",
                "wedding dress (웨딩드레스)",
                "uniform (유니폼)",
                "school uniform (교복)",
                "military uniform (군복)",
                "nurse uniform (간호복)",
                "police uniform (경찰복)",
                "business casual (비즈니스 캐주얼)",
                "athletic wear (운동복)",
                "sports uniform (스포츠 유니폼)",
                "gym pants (짐 팬츠)",
                "tracksuit (트랙수트)",
                "swimsuit (수영복)",
                "bikini (비키니)",
                "pajamas (파자마)",
                "robe (가운)",
                "traditional hanbok (한복)",
                "kimono (기모노)",
                "ethnic clothing (민족 의상)",
                "vintage clothing (빈티지 의류)"
            ],
            ACCESSORIES: [
                "eyeglasses (안경)",
                "sunglasses (선글라스)",
                "round glasses (둥근 안경)",
                "square glasses (사각 안경)",
                "aviator sunglasses (비행기 선글라스)",
                "reading glasses (독서용 안경)",
                "earrings (귀걸이)",
                "stud earrings (스터드 귀걸이)",
                "hoop earrings (링 귀걸이)",
                "drop earrings (드롭 귀걸이)",
                "pearl earrings (진주 귀걸이)",
                "necklace (목걸이)",
                "chain necklace (체인 목걸이)",
                "pendant necklace (펜던트 목걸이)",
                "choker (초커)",
                "pearl necklace (진주 목걸이)",
                "bracelet (팔찌)",
                "bangle (뱅글)",
                "watch (시계)",
                "smartwatch (스마트워치)",
                "luxury watch (명품 시계)",
                "ring (반지)",
                "wedding ring (결혼반지)",
                "multiple rings (여러 개 반지)",
                "hat (모자)",
                "cap (캡모자)",
                "beanie (비니)",
                "fedora (페도라)",
                "beret (베레모)",
                "headband (머리띠)",
                "hair clip (머리핀)",
                "scrunchie (스크런치)",
                "bow (리본)",
                "scarf (스카프)",
                "silk scarf (실크 스카프)",
                "winter scarf (겨울 목도리)",
                "tie (넥타이)",
                "bow tie (나비 넥타이)",
                "belt (벨트)",
                "leather belt (가죽 벨트)",
                "chain belt (체인 벨트)",
                "bag (가방)",
                "handbag (핸드백)",
                "shoulder bag (숄더백)",
                "crossbody bag (크로스백)",
                "clutch (클러치)",
                "backpack (백팩)",
                "tote bag (토트백)",
                "gloves (장갑)",
                "leather gloves (가죽 장갑)",
                "mittens (벙어리장갑)",
                "face mask (페이스 마스크)",
                "medical mask (의료용 마스크)",
                "brooch (브로치)",
                "pin (핀)",
                "hair accessories (헤어 액세서리)",
                "tattoo (문신)",
                "piercing (피어싱)",
                "wearing (착용하고 있는)",
                "sporting (입고/끼고 있는)",
                "adorned with (장식된)",
                "decorated with (장식된)",
                "accessorized with (액세서리한)",
                "fitted with (갖춰진)",
                "displaying (보여주는)",
                "flaunting (과시하는)",
                "donning (입고 있는)",
                "equipped with (장착한)"
            ],
            PROPS: [
                "smartphone (스마트폰)",
                "laptop (노트북)",
                "tablet (태블릿)",
                "camera (카메라)",
                "headphones (헤드폰)",
                "earbuds (이어버드)",
                "book (책)",
                "magazine (잡지)",
                "newspaper (신문)",
                "notebook (공책)",
                "pen (펜)",
                "pencil (연필)",
                "coffee cup (커피컵)",
                "mug (머그컵)",
                "water bottle (물병)",
                "tea cup (찻잔)",
                "umbrella (우산)",
                "briefcase (서류가방)",
                "suitcase (여행가방)",
                "flowers (꽃)",
                "bouquet (꽃다발)",
                "rose (장미)",
                "guitar (기타)",
                "violin (바이올린)",
                "piano (피아노)",
                "microphone (마이크)",
                "basketball (농구공)",
                "football (축구공)",
                "tennis racket (테니스 라켓)",
                "tennis ball (테니스 공)",
                "bicycle (자전거)",
                "skateboard (스케이트보드)",
                "keys (열쇠)",
                "keychain (열쇠고리)",
                "wallet (지갑)",
                "purse (지갑)",
                "map (지도)",
                "sunscreen (선크림)",
                "lipstick (립스틱)",
                "makeup (메이크업)",
                "comb (빗)",
                "scissors (가위)",
                "knife (칼)",
                "fork (포크)",
                "spoon (숟가락)",
                "chopsticks (젓가락)",
                "plate (접시)",
                "bowl (그릇)",
                "shopping bag (쇼핑백)",
                "gift box (선물상자)",
                "balloon (풍선)",
                "teddy bear (테디베어)",
                "paint brush (붓)",
                "palette (팔레트)",
                "stethoscope (청진기)",
                "syringe (주사기)",
                "hammer (망치)",
                "wrench (렌치)",
                "flashlight (손전등)",
                "binoculars (쌍안경)",
                "holding (들고 있는)",
                "carrying (들고/메고 있는)",
                "gripping (쥐고있는)",
                "clutching (꽉 쥔)",
                "wielding (휘두르는)",
                "using (사용하는)",
                "operating (조작하는)",
                "playing (연주하는/가지고 노는)"
            ],
            POSE: [
                "standing straight (똑바로 서있는)",
                "standing casual (편하게 서있는)",
                "with arms crossed (팔짱 낀 채 서있는)",
                "hands on hips (허리에 손을 얹은)",
                "leaning against wall (벽에 기댄)",
                "sitting on chair (의자에 앉은)",
                "sitting on ground (바닥에 앉은)",
                "sitting on floor (바닥에 앉은)",
                "kneeling (무릎 꿇은)",
                "crouching (쭈그리고 앉은)",
                "squatting (스쿼트 자세)",
                "lying down (누워있는)",
                "lying on side (옆으로 누운)",
                "lying on stomach (엎드려 누운)",
                "lying on back (기대어 누운)",
                "walking (걷고 있는)",
                "running (달리는)",
                "jumping (점프하는)",
                "dancing (춤추는)",
                "stretching (스트레칭하는)",
                "yoga pose (요가 자세)",
                "meditation pose (명상 자세)",
                "action pose (액션 포즈)",
                "dynamic pose (역동적인 포즈)",
                "fighting pose (격투 자세)",
                "martial arts pose (무술 자세)",
                "hands up (양손을 든)",
                "hands behind back (손을 뒤로 묶은)",
                "hands in pockets (주머니에 손을 넣은)",
                "pointing finger (손가락으로 가리키는)",
                "thumbs up (엄지 척)",
                "peace sign (브이 사인)",
                "waving hand (손 흔드는)",
                "thinking pose (생각하는 포즈)",
                "praying hands (기도하는 손)",
                "hand on chin (턱에 손을 괸)",
                "head tilt (고개 기울임)",
                "looking over shoulder (어깨 너머로 보는)",
                "back turned (등을 돌린)",
                "profile view (측면 모습)",
                "three-quarter view (3/4 각도)",
                "contrapposto (콘트라포스토)",
                "model pose (모델 포즈)",
                "casual lean (편안한 기댄)",
                "confident stance (자신감 있는 자세)",
                "shy pose (수줍은 포즈)",
                "playful pose (장난스러운 포즈)",
                "elegant pose (우아한 포즈)",
                "power pose (파워 포즈)",
                "relaxed posture (편안한 자세)",
                "tense posture (긴장한 자세)",
                "slouching (구부정한)",
                "straight posture (바른 자세)"
            ],
            CAMERA: [
                "extreme close-up (익스트림 클로즈업)",
                "close-up (클로즈업)",
                "medium shot (미디엄 샷)",
                "cowboy shot (카우보이 샷)",
                "full shot (풀 샷)",
                "wide shot (와이드 샷)",
                "extreme wide shot (익스트림 와이드 샷)",
                "eye level (아이 레벨 (보통의 높이))",
                "low angle (로우 앵글 (아래에서 위로))",
                "high angle (하이 앵글 (위에서 아래로))",
                "bird's eye view (버드 아이 뷰 (조류 뷰))",
                "overhead shot (오버헤드 샷 (머리 위))",
                "dutch angle (더치 앵글 (기울어진))",
                "worm's eye view (웜즈 아이 뷰 (지면에서))",
                "ground level (그라운드 레벨 (지면))",
                "side view (사이드 뷰 (측면))",
                "back view (백 뷰 (후면))",
                "3/4 view (3/4 뷰 (3/4 각도))",
                "profile view (프로파일 뷰 (옆모습))",
                "rear 3/4 view (리어 쓰리쿼터 뷰 (후면 3/4))",
                "POV shot (POV 샷 (1인칭 시점))",
                "over-the-shoulder shot (오버 더 숄더 샷 (어깨 너머))",
                "two shot (투 샷 (2인 구도))",
                "three shot (쓰리 샷 (3인 구도))",
                "group shot (그룹 샷 (단체))",
                "establishing shot (설정 샷 (장소/상황 소개))",
                "master shot (마스터 샷 (전체 장면))",
                "insert shot (인서트 샷)",
                "rule of thirds (3분할 구도)",
                "center composition (중앙 구도)",
                "symmetrical shot (대칭 구도)",
                "frame within frame (프레임 안 프레임 (액자 구도))",
                "diagonal composition (대각선 구도)",
                "layered shot (레이어드 샷 (층 구도))",
                "negative space (네거티브 스페이스 (여백 구도))"
            ],
            CAMERA_EFFECTS: [
                "bokeh, blurred background lights (보케, 흐린 배경 조명)",
                "chromatic aberration, color fringing (색수차, 색 테두리)",
                "deep depth of field, everything in focus (깊은 피사계 심도, 전체 초점)",
                "double exposure, layered images (이중 노출, 겹친 이미지)",
                "echo effect, motion repetition (잔상 효과, 움직임 반복)",
                "film grain, vintage texture (필름 그레인, 빈티지 질감)",
                "fisheye lens, extreme wide angle (피쉬아이 렌즈, 극단적 광각)",
                "flowing motion, smooth movement (부드러운 움직임, 유연한 동작)",
                "frozen motion, sharp action (동작 정지, 선명한 동작)",
                "glitch effect, digital artifacts (글리치 효과, 디지털 왜곡)",
                "high contrast, dramatic lighting (하이 컨트라스트, 극적인 조명)",
                "high-speed action, dynamic movement (고속 동작, 역동적 움직임)",
                "infrared effect, heat vision (적외선 효과, 열화상)",
                "lens flare, sun rays (렌즈 플레어, 태양 광선)",
                "light leak, vintage glow (라이트 리크, 빈티지 빛샘)",
                "long exposure, light trails (장노출, 빛 궤적)",
                "motion blur, fast movement (모션 블러, 빠른 움직임)",
                "motion trail, movement path (움직임 흔적, 동작 경로)",
                "multiple exposure, overlapping images (다중 노출, 겹친 이미지)",
                "panning blur, horizontal motion (패닝 블러, 수평 움직임)",
                "rack focus, focus transition (랙 포커스, 초점 전환)",
                "reflection, mirror effect (반사 효과, 거울 효과)",
                "shallow depth of field, background blur (얕은 피사계 심도, 배경 흐림)",
                "silhouette, backlit subject (실루엣, 역광 피사체)",
                "soft focus, dreamy effect (소프트 포커스, 몽환적 효과)",
                "speed blur, sense of speed (스피드 라인, 속도감)",
                "spin blur, rotating motion (회전 블러, 회전 움직임)",
                "split screen, divided frame (스플릿 스크린, 분할 화면)",
                "through glass, window view (유리 너머, 창문 뷰)",
                "tilt-shift, miniature effect (틸트 시프트, 미니어처 효과)",
                "tunnel vision, focus effect (터널 비전, 집중 효과)",
                "underwater effect, submerged view (수중 효과, 물속 장면)",
                "vignette, darkened edges (비네팅, 어두운 테두리)",
                "wide angle distortion, stretched edges (광각 왜곡, 늘어난 가장자리)",
                "zoom burst, radial blur (줌 버스트, 방사형 블러)"
            ],
            CAMERA_TECH: [],
            LOCATION: [
                "abandoned bus (버려진 건물)",
                "airport (공항)",
                "alleyway (골목길)",
                "art gallery (미술관)",
                "attic (다락방)",
                "balcony (발코니)",
                "bar (바)",
                "basement (지하실)",
                "bathroom (욕실)",
                "beach (해변)",
                "bookstore (서점)",
                "bus stop (버스 정류장)",
                "church (교회)",
                "city street (도시 거리)",
                "clinic (진료소)",
                "coffee shop (커피숍)",
                "concert hall (콘서트홀)",
                "construction site (공사 현장)",
                "convenience store (편의점)",
                "corporate office (기업 사무실)",
                "coworking space (코워킹 스페이스)",
                "cozy bedroom (아늑한 침실)",
                "crosswalk (횡단보도)",
                "dance studio (댄스 스튜디오)",
                "department store (백화점)",
                "desert (사막)",
                "downtown (도심)",
                "executive office (임원실)",
                "factory (공장)",
                "farm (농장)",
                "field (들판)",
                "garage (차고)",
                "garden (정원)",
                "greenhouse (온실)",
                "gym (헬스장)",
                "home office (홈 오피스)",
                "hospital (병원)",
                "inside airplane (비행기 내부)",
                "inside car (자동차 내부)",
                "inside train (기차 내부)",
                "jungle (정글)",
                "lake (호수)",
                "library (도서관)",
                "luxury kitchen (고급 주방)",
                "meadow (초원)",
                "meeting room (회의실)",
                "modern living room (현대적 거실)",
                "mountain (산)",
                "museum (박물관)",
                "office lobby (오피스 로비)",
                "park (공원)",
                "parking lot (주차장)",
                "photo studio (포토 스튜디오)",
                "recording studio (녹음실)",
                "residential area (주거 지역)",
                "restaurant (레스토랑)",
                "riverside (강변)",
                "rooftop (옥상)",
                "school classroom (학교 교실)",
                "shopping mall (쇼핑몰)",
                "studio (스튜디오)",
                "subway station (지하철역)",
                "temple (사원)",
                "theater (극장)",
                "train station (기차역)",
                "university campus (대학 캠퍼스)",
                "warehouse (창고)"
            ],
            LOCATION_DETAIL: [],
            TIME_LIGHTING: [
                "pre-dawn light (새벽 전 빛)",
                "dawn light (아침)",
                "sunrise (일출)",
                "early morning light (이른 아침 빛)",
                "morning light (아침 빛)",
                "noon sun (점심 대낮)",
                "midday light (한낮 빛)",
                "early afternoon light (이른 오후 빛)",
                "afternoon light (오후 빛)",
                "late afternoon light (늦은 오후 빛)",
                "golden hour (골든 아워)",
                "sunset (일몰)",
                "blue hour (블루 아워)",
                "dusk (석양)",
                "twilight (땅거미)",
                "night (밤)",
                "moonlight (달빛)",
                "starlight (별빛)",
                "candlelight (촛불빛)",
                "new moon darkness (그믐달 어둠)",
                "northern lights (오로라)",
                "overcast light (흐린 날 빛)",
                "cloudy day light (구름 낀 날 빛)",
                "foggy light (안개 낀 빛)",
                "stormy light (폭풍우 빛)",
                "snowy light (눈 내리는 빛)"
            ],
            ARTIFICIAL_LIGHT: [
                "ceiling light (천장등)",
                "chandelier (샹들리에)",
                "table lamp (탁상등 램프)",
                "fluorescent tubes (형광등)",
                "pendant light (펜던트 조명)",
                "reading light (독서등)",
                "recessed lighting (매립등)",
                "studio lights (스튜디오 조명)",
                "table lamp (탁상등)",
                "neon signs (네온 램프)",
                "task lighting (작업등)",
                "track lighting (트랙 조명)",
                "wall sconce (벽등)",
                "bathroom vanity light (욕실 화장대 조명)",
                "building facade light (건물 외벽 조명)",
                "street lights (가로등)",
                "garden lights (정원등)",
                "street lamps (가로등)",
                "security lights (보안등)",
                "industrial lights (산업용 조명)",
                "parking lot lights (주차장 조명)",
                "billboard lights (광고판 조명)",
                "traffic lights (신호등)",
                "fireworks (불꽃놀이)",
                "concert lighting (콘서트 조명)",
                "stage lighting (무대 조명)",
                "nightclub lighting (나이트클럽 조명)",
                "stadium lights (경기장 조명)",
                "theater spotlights (극장 스포트라이트)",
                "ambient lighting (주변 조명)",
                "accent lighting (강조 조명)",
                "mood lighting (무드 조명)",
                "backlight (백라이트)",
                "candles (촛불)",
                "candlelight (촛불빛)",
                "fireplace glow (벽난로 불빛)",
                "fire light (모닥불 빛)",
                "neon bulb (네온 전구)",
                "fairy lights (페어리 라이트)",
                "string lights (줄조명)",
                "christmas lights (크리스마스 조명)",
                "spotlights (스포트라이트)",
                "floodlights (투광 조명)",
                "led strips (LED 스트립)",
                "blacklight (블랙라이트)",
                "colored light (컬러 조명)",
                "glowstick (야광봉)",
                "laser light (레이저)",
                "paper lanterns (종이 랜턴)",
                "torch (횃불)",
                "lamplight (램프빛)",
                "projector light (프로젝터 빛)",
                "screen light (스크린 빛)"
            ],
            ATMOSPHERE: [
                "peaceful (평화로운)",
                "serene (고요한)",
                "tranquil (평온한)",
                "calm (차분한)",
                "relaxed (편안한)",
                "cozy (아늑한)",
                "warm (따뜻한)",
                "intimate (친밀한)",
                "romantic (로맨틱한)",
                "dreamy (몽환적인)",
                "nostalgic (향수어린)",
                "melancholic (우울한)",
                "lonely (외로운)",
                "isolated (고립된)",
                "mysterious (신비로운)",
                "eerie (으스스한)",
                "ominous (불길한)",
                "tense (긴장된)",
                "moody (분위기있는)",
                "dramatic (드라마틱한)",
                "tense (긴장된)",
                "suspenseful (긴박한)",
                "urgent (긴급한)",
                "chaotic (혼란스러운)",
                "energetic (활기찬)",
                "vibrant (생동감있는)",
                "lively (활발한)",
                "joyful (즐거운)",
                "cheerful (명랑한)",
                "playful (장난스러운)",
                "festive (축제같은)",
                "celebratory (축하하는)",
                "professional (전문적인)",
                "formal (격식있는)",
                "elegant (우아한)",
                "luxurious (고급스러운)",
                "minimalist (미니멀한)",
                "modern (현대적인)",
                "vintage (빈티지한)",
                "retro (레트로한)",
                "ethereal (천상의)",
                "magical (마법같은)",
                "fantastical (환상적인)",
                "surreal (초현실적인)",
                "apocalyptic (종말론적인)",
                "dystopian (디스토피아적인)",
                "hopeful (희망적인)",
                "inspiring (영감을주는)",
                "contemplative (사색적인)",
                "meditative (명상적인)"
            ],
            WEATHER: [
                "clear sky (맑은 하늘)",
                "sunny (화창한)",
                "partly cloudy (부분적으로 흐린)",
                "cloudy (흐린)",
                "overcast (구름 많은)",
                "dark clouds (먹구름)",
                "hazy (아지랑이 낀)",
                "smog (안개 낀)",
                "foggy (짙은 안개)",
                "misty (옅은 안개)",
                "drizzle (이슬비)",
                "light rain (가벼운 비)",
                "rainy (비오는)",
                "heavy rain (폭우)",
                "torrential rain (집중호우)",
                "thunderstorm (뇌우)",
                "thunder and lightning (천둥과 번개)",
                "light snow (가벼운 눈)",
                "snowy (눈오는)",
                "heavy snow (폭설)",
                "snowstorm (눈보라)",
                "blizzard (블리자드)",
                "hailstorm (우박)",
                "sleet (진눈깨비)",
                "windy (바람부는)",
                "strong wind (강풍)",
                "gentle breeze (산들바람)",
                "hurricane (허리케인)",
                "tornado (토네이도)",
                "sandstorm (모래폭풍)",
                "dust storm (먼지폭풍)",
                "rainbow (무지개)",
                "double rainbow (쌍무지개)",
                "crepuscular rays (햇살)",
                "aurora (오로라)",
                "northern lights (북극광)",
                "hot and humid (덥고 습한)",
                "cold and dry (춥고 건조한)",
                "freezing (빙점)",
                "scorching (타는듯한 더위)",
                "spring weather (봄날씨)",
                "autumn weather (가을날씨)",
                "monsoon (몬순)",
                "typhoon (태풍)"
            ],
            FOREGROUND: [],
            BACKGROUND: [
                "transparent background (투명 배경)",
                "white background (흰색 배경)",
                "black background (검은색 배경)",
                "gray background (회색 배경)",
                "gradient background (그라데이션 배경)",
                "solid color background (단색 배경)",
                "gradient background (그라데이션 배경)",
                "soft gradient (부드러운 그라데이션)",
                "radial gradient (방사형 그라데이션)",
                "linear gradient (선형 그라데이션)",
                "pastel gradient (파스텔 그라데이션)",
                "color gradient (컬러 그라데이션)",
                "studio backdrop (스튜디오 배경)",
                "photography backdrop (사진 배경막)",
                "seamless backdrop (심리스 배경)",
                "paper backdrop (종이 배경)",
                "fabric backdrop (패브릭 배경)",
                "simple background (단순한 배경)",
                "minimal background (미니멀 배경)",
                "abstract background (추상적 배경)",
                "plain background (무지 배경)",
                "blurred background (흐린 배경)",
                "bokeh background (보케 배경)",
                "soft focus background (소프트 포커스 배경)",
                "abstract background (추상적 배경)",
                "geometric background (기하학적 배경)",
                "pattern background (패턴 배경)",
                "textured background (질감있는 배경)",
                "light background (밝은 배경)",
                "dark background (어두운 배경)",
                "colorful background (다채로운 배경)",
                "monochrome background (모노톤 배경)",
                "vignette background (비네팅 배경)",
                "spotlight background (스포트라이트 배경)",
                "rim light background (림라이트 배경)",
                "backlit background (역광 배경)",
                "neon background (네온 배경)",
                "glowing background (빛나는 배경)",
                "misty background (안개 배경)",
                "foggy background (포그 배경)",
                "sky background (하늘 배경)",
                "sunset gradient (일몰 그라데이션)",
                "rainbow gradient (무지개 그라데이션)",
                "pastel tone background (파스텔톤 배경)",
                "split background (분할 배경)",
                "frame background (프레임 배경)",
                "circular backdrop (원형 배경막)"
            ],
            LIGHTING: [
                "rembrandt lighting (렘브란트 조명)",
                "butterfly lighting (나비 조명)",
                "loop lighting (루프 조명)",
                "split lighting (분할 조명)",
                "broad lighting (브로드 조명)",
                "short lighting (쇼트 조명)",
                "paramount lighting (파라마운트 조명)",
                "chiaroscuro lighting (키아로스쿠로 조명)",
                "clamshell lighting (클램쉘 조명)",
                "rim lighting (림 라이팅)",
                "backlighting (백라이팅)",
                "silhouette lighting (실루엣 조명)",
                "three-point lighting (3점 조명)",
                "key light only (키 라이트만)",
                "fill light (필 라이트)",
                "soft lighting (부드러운 조명)",
                "hard lighting (딱딱한 조명)",
                "diffused lighting (확산 조명)",
                "natural lighting (자연광)",
                "window lighting (창문 조명)",
                "golden hour lighting (골든아워 조명)",
                "blue hour lighting (블루아워 조명)",
                "portrait lighting (인물 조명)",
                "studio lighting (스튜디오 조명)",
                "fashion lighting (패션 조명)",
                "glamour lighting (글래머 조명)",
                "dramatic lighting (드라마틱 조명)",
                "moody lighting (무디한 조명)",
                "high key lighting (하이키 조명)",
                "low key lighting (로우키 조명)",
                "flat lighting (플랫 조명)",
                "cross lighting (크로스 조명)",
                "top lighting (탑 라이팅)",
                "bottom lighting (바텀 조명)",
                "face lighting (얼굴 조명)",
                "ring light (링 라이트)",
                "patch light (패치 라이트)",
                "eye light (아이 라이트)",
                "hair light (헤어 라이트)",
                "kicker light (키커 라이트)",
                "background light (배경 조명)",
                "separation light (분리 조명)",
                "contour lighting (윤곽 조명)",
                "cross lighting (크로스 조명)",
                "colored lighting (컬러 조명)",
                "accent lighting (악센트 조명)",
                "warm lighting (따뜻한 조명)",
                "cool lighting (차가운 조명)",
                "cinematic lighting (영화적 조명)"
            ],
            LIGHTING_TECHNIQUE: [
                "atmospheric lighting (대기 조명)",
                "available light (가용광)",
                "back lighting (역광)",
                "blue hour lighting (블루 아워 조명)",
                "bottom lighting (바닥 조명)",
                "bounce lighting (반사 조명)",
                "broad lighting (브로드 조명)",
                "butterfly lighting (나비 조명)",
                "chiaroscuro lighting (키아로스쿠로 조명)",
                "cinematic lighting (시네마틱 조명)",
                "color gel lighting (컬러 젤 조명)",
                "cross lighting (크로스 조명)",
                "diffused lighting (확산 조명)",
                "direct lighting (직접 조명)",
                "dramatic lighting (드라마틱 조명)",
                "fill lighting (필 라이팅)",
                "front lighting (정면 조명)",
                "gobo lighting (고보 조명)",
                "god rays (신의 광선)",
                "golden hour lighting (골든 아워 조명)",
                "hard lighting (강한 조명)",
                "high key lighting (하이키 조명)",
                "kicker lighting (키커 조명)",
                "key lighting (키 조명)",
                "loop lighting (루프 조명)",
                "low key lighting (로우키 조명)",
                "mid key lighting (미드키 조명)",
                "motivated lighting (동기 조명)",
                "natural lighting (자연 조명)",
                "portrait lighting (인물 조명)",
                "practical lighting (실용 조명)",
                "rembrandt lighting (렘브란트 조명)",
                "rim lighting (림 라이팅)",
                "short lighting (쇼트 조명)",
                "side lighting (측면 조명)",
                "silhouette lighting (실루엣 조명)",
                "soft lighting (부드러운 조명)",
                "specular lighting (정반사 조명)",
                "split lighting (스플릿 조명)",
                "studio lighting (스튜디오 조명)",
                "three-point lighting (3점 조명)",
                "top lighting (탑 라이팅)",
                "volumetric lighting (볼륨메트릭 조명)"
            ],
            QUALITY: [
                "highly detailed (매우 상세한)",
                "award winning (수상작 수준)",
                "professional (전문가 수준)",
                "masterpiece (걸작)",
                "expert quality (전문가 품질)",
                "museum quality (박물관 소장품 수준)",
                "commercial quality (상업적 품질)",
                "studio quality (스튜디오 품질)",
                "photorealistic (사실적인)",
                "hyperrealistic (초현실적으로 사실적인)",
                "ultra detailed (초고해상도)",
                "high resolution (고해상도)",
                "4K quality (4K 품질)",
                "8K quality (8K 품질)",
                "cinematic quality (영화적 품질)",
                "cinematic grade (영화 등급)",
                "professional grade (전문가 등급)",
                "broadcast quality (방송 품질)",
                "sharp focus (선명한 초점)",
                "crystal clear (수정처럼 맑은)",
                "pristine quality (흠잡을 데 없는 품질)",
                "flawless (완벽한)",
                "polished (세련된)",
                "refined (정제된)",
                "high quality photography (고급 사진)",
                "premium quality (프리미엄 품질)",
                "exceptional detail (뛰어난 디테일)",
                "stunning quality (놀라운 품질)",
                "impeccable (흠잡을 데 없는)",
                "artistic quality (예술적 품질)",
                "gallery quality (갤러리 수준)"
            ],
            PARAMETERS: [
                "--ar 1:1 - 화면 비율 1:1 (정사각형)",
                "--ar 4:5 - 화면 비율 4:5",
                "--ar 2:3 - 화면 비율 2:3",
                "--ar 4:7 - 화면 비율 4:7",
                "--ar 5:4 - 화면 비율 5:4",
                "--ar 3:2 - 화면 비율 3:2",
                "--ar 7:4 - 화면 비율 7:4",
                "--ar 4:3 - 화면 비율 4:3",
                "--ar 9:16 - 화면 비율 9:16 (세로)",
                "--ar 16:9 - 화면 비율 16:9 (가로)",
                "--ar 21:9 - 화면 비율 21:9 (울트라와이드)",
                "--v 7 - 버전 7 (최신)",
                "--v 6.1 - 버전 6.1",
                "--v 6 - 버전 6",
                "--style raw - 가공되지 않은 스타일",
                "--style cute - 귀여운 스타일 (니지용)",
                "--style scenic - 경치 스타일 (니지용)",
                "--s 0 - 스타일라이즈 0 (최소)",
                "--s 100 - 스타일라이즈 100 (기본값)",
                "--s 250 - 스타일라이즈 250",
                "--s 500 - 스타일라이즈 500",
                "--s 750 - 스타일라이즈 750",
                "--s 1000 - 스타일라이즈 1000 (최대)",
                "--c 0 - 카오스 0 (일관성 높음)",
                "--c 25 - 카오스 25",
                "--c 50 - 카오스 50",
                "--c 100 - 카오스 100 (매우 다양함)",
                "--w 0 - 기묘함 0 (없음)",
                "--w 250 - 기묘함 250",
                "--w 500 - 기묘함 500",
                "--w 1000 - 기묘함 1000",
                "--q .25 - 품질 0.25 (빠름)",
                "--q .5 - 품질 0.5",
                "--q 1 - 품질 1 (기본값)",
                "--iw 0.25 - 이미지 가중치 0.5",
                "--iw 1 - 이미지 가중치 1 (기본값)",
                "--iw 2 - 이미지 가중치 2 (강함)",
                "--cref URL - 캐릭터 참조 URL",
                "--cw 0 - 캐릭터 가중치 0",
                "--cw 50 - 캐릭터 가중치 50",
                "--cw 100 - 캐릭터 가중치 100 (기본값)",
                "--sref URL - 스타일 참조 URL",
                "--sw 0 - 스타일 가중치 0",
                "--sw 50 - 스타일 가중치 50",
                "--sw 100 - 스타일 가중치 100 (기본값)",
                "--no text - 텍스트 제외",
                "--no watermark - 워터마크 제외",
                "--no person - 사람 제외",
                "--seed 12345 - 시드 번호 지정",
                "--tile - 타일 패턴 생성",
                "--repeat 2 - 2회 반복 생성",
                "--repeat 4 - 4회 반복 생성",
                "--video - 생성 과정 비디오",
                "--stop 50 - 50%에서 중단",
                "--stop 80 - 80%에서 중단",
                "--niji 6 - 니지 모드 버전 6 (애니메이션)",
                "--turbo - 터보 모드",
                "--fast - 빠른 모드",
                "--relax - 릴렉스 모드",
                "--exp - 실험적 모드",
                "--ow - 원본 가중치 모드"
            ],
            // 일반 이미지 탭용 캐릭터 옵션
            CHARACTER_1: [
                "Korean male child (한국 남자 어린이)",
                "Korean female child (한국 여자 어린이)",
                "Korean male teen (한국 남자 청소년)",
                "Korean female teen (한국 여자 청소년)",
                "Korean male 20s (한국 남자 20대)",
                "Korean female 20s (한국 여자 20대)",
                "Korean male 30s (한국 남자 30대)",
                "Korean female 30s (한국 여자 30대)",
                "Korean male 40s (한국 남자 40대)",
                "Korean female 40s (한국 여자 40대)",
                "Korean male 50s (한국 남자 50대)",
                "Korean female 50s (한국 여자 50대)",
                "Korean male 60s (한국 남자 60대)",
                "Korean female 60s (한국 여자 60대)",
                "Korean male 70s+ (한국 남자 70대 이상)",
                "Korean female 70s+ (한국 여자 70대 이상)",
                "Japanese male teen (일본 남자 청소년)",
                "Japanese female teen (일본 여자 청소년)",
                "Japanese male 20s (일본 남자 20대)",
                "Japanese female 20s (일본 여자 20대)",
                "Japanese male 30s (일본 남자 30대)",
                "Japanese female 30s (일본 여자 30대)",
                "Japanese male 40s (일본 남자 40대)",
                "Japanese female 40s (일본 여자 40대)",
                "Chinese male 20s (중국 남자 20대)",
                "Chinese female 20s (중국 여자 20대)",
                "Chinese male 30s (중국 남자 30대)",
                "Chinese female 30s (중국 여자 30대)",
                "Chinese male 40s (중국 남자 40대)",
                "Chinese female 40s (중국 여자 40대)",
                "American male teen (미국 남자 청소년)",
                "American female teen (미국 여자 청소년)",
                "American male 20s (미국 남자 20대)",
                "American female 20s (미국 여자 20대)",
                "American male 30s (미국 남자 30대)",
                "American female 30s (미국 여자 30대)",
                "American male 40s (미국 남자 40대)",
                "American female 40s (미국 여자 40대)",
                "American male 50s (미국 남자 50대)",
                "American female 50s (미국 여자 50대)",
                "European male 20s (유럽 남자 20대)",
                "European female 20s (유럽 여자 20대)",
                "European male 30s (유럽 남자 30대)",
                "European female 30s (유럽 여자 30대)",
                "European male 40s (유럽 남자 40대)",
                "European female 40s (유럽 여자 40대)",
                "British male 30s (영국 남자 30대)",
                "British female 30s (영국 여자 30대)",
                "French male 30s (프랑스 남자 30대)",
                "French female 30s (프랑스 여자 30대)",
                "German male 30s (독일 남자 30대)",
                "German female 30s (독일 여자 30대)",
                "Italian male 30s (이탈리아 남자 30대)",
                "Italian female 30s (이탈리아 여자 30대)",
                "Indian male 20s (인도 남자 20대)",
                "Indian female 20s (인도 여자 20대)",
                "Indian male 30s (인도 남자 30대)",
                "Indian female 30s (인도 여자 30대)",
                "Southeast Asian male 20s (동남아시아 남자 20대)",
                "Southeast Asian female 20s (동남아시아 여자 20대)",
                "Southeast Asian male 30s (동남아시아 남자 30대)",
                "Southeast Asian female 30s (동남아시아 여자 30대)",
                "Latin American male 20s (라틴 아메리카 남자 20대)",
                "Latin American female 20s (라틴 아메리카 여자 20대)",
                "Latin American male 30s (라틴 아메리카 남자 30대)",
                "Latin American female 30s (라틴 아메리카 여자 30대)",
                "Middle Eastern male 30s (중동 남자 30대)",
                "Middle Eastern female 30s (중동 여자 30대)",
                "African male 20s (아프리카 남자 20대)",
                "African female 20s (아프리카 여자 20대)",
                "African male 30s (아프리카 남자 30대)",
                "African female 30s (아프리카 여자 30대)"
            ],
            CHARACTER_1_DETAIL: [],
            CHARACTER_2: [
                "Korean male child (한국 남자 어린이)",
                "Korean female child (한국 여자 어린이)",
                "Korean male teen (한국 남자 청소년)",
                "Korean female teen (한국 여자 청소년)",
                "Korean male 20s (한국 남자 20대)",
                "Korean female 20s (한국 여자 20대)",
                "Korean male 30s (한국 남자 30대)",
                "Korean female 30s (한국 여자 30대)",
                "Korean male 40s (한국 남자 40대)",
                "Korean female 40s (한국 여자 40대)",
                "Korean male 50s (한국 남자 50대)",
                "Korean female 50s (한국 여자 50대)",
                "Korean male 60s (한국 남자 60대)",
                "Korean female 60s (한국 여자 60대)",
                "Korean male 70s+ (한국 남자 70대 이상)",
                "Korean female 70s+ (한국 여자 70대 이상)",
                "Japanese male teen (일본 남자 청소년)",
                "Japanese female teen (일본 여자 청소년)",
                "Japanese male 20s (일본 남자 20대)",
                "Japanese female 20s (일본 여자 20대)",
                "Japanese male 30s (일본 남자 30대)",
                "Japanese female 30s (일본 여자 30대)",
                "Japanese male 40s (일본 남자 40대)",
                "Japanese female 40s (일본 여자 40대)",
                "Chinese male 20s (중국 남자 20대)",
                "Chinese female 20s (중국 여자 20대)",
                "Chinese male 30s (중국 남자 30대)",
                "Chinese female 30s (중국 여자 30대)",
                "Chinese male 40s (중국 남자 40대)",
                "Chinese female 40s (중국 여자 40대)",
                "American male teen (미국 남자 청소년)",
                "American female teen (미국 여자 청소년)",
                "American male 20s (미국 남자 20대)",
                "American female 20s (미국 여자 20대)",
                "American male 30s (미국 남자 30대)",
                "American female 30s (미국 여자 30대)",
                "American male 40s (미국 남자 40대)",
                "American female 40s (미국 여자 40대)",
                "American male 50s (미국 남자 50대)",
                "American female 50s (미국 여자 50대)",
                "European male 20s (유럽 남자 20대)",
                "European female 20s (유럽 여자 20대)",
                "European male 30s (유럽 남자 30대)",
                "European female 30s (유럽 여자 30대)",
                "European male 40s (유럽 남자 40대)",
                "European female 40s (유럽 여자 40대)",
                "British male 30s (영국 남자 30대)",
                "British female 30s (영국 여자 30대)",
                "French male 30s (프랑스 남자 30대)",
                "French female 30s (프랑스 여자 30대)",
                "German male 30s (독일 남자 30대)",
                "German female 30s (독일 여자 30대)",
                "Italian male 30s (이탈리아 남자 30대)",
                "Italian female 30s (이탈리아 여자 30대)",
                "Indian male 20s (인도 남자 20대)",
                "Indian female 20s (인도 여자 20대)",
                "Indian male 30s (인도 남자 30대)",
                "Indian female 30s (인도 여자 30대)",
                "Southeast Asian male 20s (동남아시아 남자 20대)",
                "Southeast Asian female 20s (동남아시아 여자 20대)",
                "Southeast Asian male 30s (동남아시아 남자 30대)",
                "Southeast Asian female 30s (동남아시아 여자 30대)",
                "Latin American male 20s (라틴 아메리카 남자 20대)",
                "Latin American female 20s (라틴 아메리카 여자 20대)",
                "Latin American male 30s (라틴 아메리카 남자 30대)",
                "Latin American female 30s (라틴 아메리카 여자 30대)",
                "Middle Eastern male 30s (중동 남자 30대)",
                "Middle Eastern female 30s (중동 여자 30대)",
                "African male 20s (아프리카 남자 20대)",
                "African female 20s (아프리카 여자 20대)",
                "African male 30s (아프리카 남자 30대)",
                "African female 30s (아프리카 여자 30대)"
            ],
            CHARACTER_2_DETAIL: [],
            CHARACTER_3: [
                "Korean male child (한국 남자 어린이)",
                "Korean female child (한국 여자 어린이)",
                "Korean male teen (한국 남자 청소년)",
                "Korean female teen (한국 여자 청소년)",
                "Korean male 20s (한국 남자 20대)",
                "Korean female 20s (한국 여자 20대)",
                "Korean male 30s (한국 남자 30대)",
                "Korean female 30s (한국 여자 30대)",
                "Korean male 40s (한국 남자 40대)",
                "Korean female 40s (한국 여자 40대)",
                "Korean male 50s (한국 남자 50대)",
                "Korean female 50s (한국 여자 50대)",
                "Korean male 60s (한국 남자 60대)",
                "Korean female 60s (한국 여자 60대)",
                "Korean male 70s+ (한국 남자 70대 이상)",
                "Korean female 70s+ (한국 여자 70대 이상)",
                "Japanese male teen (일본 남자 청소년)",
                "Japanese female teen (일본 여자 청소년)",
                "Japanese male 20s (일본 남자 20대)",
                "Japanese female 20s (일본 여자 20대)",
                "Japanese male 30s (일본 남자 30대)",
                "Japanese female 30s (일본 여자 30대)",
                "Japanese male 40s (일본 남자 40대)",
                "Japanese female 40s (일본 여자 40대)",
                "Chinese male 20s (중국 남자 20대)",
                "Chinese female 20s (중국 여자 20대)",
                "Chinese male 30s (중국 남자 30대)",
                "Chinese female 30s (중국 여자 30대)",
                "Chinese male 40s (중국 남자 40대)",
                "Chinese female 40s (중국 여자 40대)",
                "American male teen (미국 남자 청소년)",
                "American female teen (미국 여자 청소년)",
                "American male 20s (미국 남자 20대)",
                "American female 20s (미국 여자 20대)",
                "American male 30s (미국 남자 30대)",
                "American female 30s (미국 여자 30대)",
                "American male 40s (미국 남자 40대)",
                "American female 40s (미국 여자 40대)",
                "American male 50s (미국 남자 50대)",
                "American female 50s (미국 여자 50대)",
                "European male 20s (유럽 남자 20대)",
                "European female 20s (유럽 여자 20대)",
                "European male 30s (유럽 남자 30대)",
                "European female 30s (유럽 여자 30대)",
                "European male 40s (유럽 남자 40대)",
                "European female 40s (유럽 여자 40대)",
                "British male 30s (영국 남자 30대)",
                "British female 30s (영국 여자 30대)",
                "French male 30s (프랑스 남자 30대)",
                "French female 30s (프랑스 여자 30대)",
                "German male 30s (독일 남자 30대)",
                "German female 30s (독일 여자 30대)",
                "Italian male 30s (이탈리아 남자 30대)",
                "Italian female 30s (이탈리아 여자 30대)",
                "Indian male 20s (인도 남자 20대)",
                "Indian female 20s (인도 여자 20대)",
                "Indian male 30s (인도 남자 30대)",
                "Indian female 30s (인도 여자 30대)",
                "Southeast Asian male 20s (동남아시아 남자 20대)",
                "Southeast Asian female 20s (동남아시아 여자 20대)",
                "Southeast Asian male 30s (동남아시아 남자 30대)",
                "Southeast Asian female 30s (동남아시아 여자 30대)",
                "Latin American male 20s (라틴 아메리카 남자 20대)",
                "Latin American female 20s (라틴 아메리카 여자 20대)",
                "Latin American male 30s (라틴 아메리카 남자 30대)",
                "Latin American female 30s (라틴 아메리카 여자 30대)",
                "Middle Eastern male 30s (중동 남자 30대)",
                "Middle Eastern female 30s (중동 여자 30대)",
                "African male 20s (아프리카 남자 20대)",
                "African female 20s (아프리카 여자 20대)",
                "African male 30s (아프리카 남자 30대)",
                "African female 30s (아프리카 여자 30대)"
            ],
            CHARACTER_3_DETAIL: [],
            CHARACTER_4: [
                "Korean male child (한국 남자 어린이)",
                "Korean female child (한국 여자 어린이)",
                "Korean male teen (한국 남자 청소년)",
                "Korean female teen (한국 여자 청소년)",
                "Korean male 20s (한국 남자 20대)",
                "Korean female 20s (한국 여자 20대)",
                "Korean male 30s (한국 남자 30대)",
                "Korean female 30s (한국 여자 30대)",
                "Korean male 40s (한국 남자 40대)",
                "Korean female 40s (한국 여자 40대)",
                "Korean male 50s (한국 남자 50대)",
                "Korean female 50s (한국 여자 50대)",
                "Korean male 60s (한국 남자 60대)",
                "Korean female 60s (한국 여자 60대)",
                "Korean male 70s+ (한국 남자 70대 이상)",
                "Korean female 70s+ (한국 여자 70대 이상)",
                "Japanese male teen (일본 남자 청소년)",
                "Japanese female teen (일본 여자 청소년)",
                "Japanese male 20s (일본 남자 20대)",
                "Japanese female 20s (일본 여자 20대)",
                "Japanese male 30s (일본 남자 30대)",
                "Japanese female 30s (일본 여자 30대)",
                "Japanese male 40s (일본 남자 40대)",
                "Japanese female 40s (일본 여자 40대)",
                "Chinese male 20s (중국 남자 20대)",
                "Chinese female 20s (중국 여자 20대)",
                "Chinese male 30s (중국 남자 30대)",
                "Chinese female 30s (중국 여자 30대)",
                "Chinese male 40s (중국 남자 40대)",
                "Chinese female 40s (중국 여자 40대)",
                "American male teen (미국 남자 청소년)",
                "American female teen (미국 여자 청소년)",
                "American male 20s (미국 남자 20대)",
                "American female 20s (미국 여자 20대)",
                "American male 30s (미국 남자 30대)",
                "American female 30s (미국 여자 30대)",
                "American male 40s (미국 남자 40대)",
                "American female 40s (미국 여자 40대)",
                "American male 50s (미국 남자 50대)",
                "American female 50s (미국 여자 50대)",
                "European male 20s (유럽 남자 20대)",
                "European female 20s (유럽 여자 20대)",
                "European male 30s (유럽 남자 30대)",
                "European female 30s (유럽 여자 30대)",
                "European male 40s (유럽 남자 40대)",
                "European female 40s (유럽 여자 40대)",
                "British male 30s (영국 남자 30대)",
                "British female 30s (영국 여자 30대)",
                "French male 30s (프랑스 남자 30대)",
                "French female 30s (프랑스 여자 30대)",
                "German male 30s (독일 남자 30대)",
                "German female 30s (독일 여자 30대)",
                "Italian male 30s (이탈리아 남자 30대)",
                "Italian female 30s (이탈리아 여자 30대)",
                "Indian male 20s (인도 남자 20대)",
                "Indian female 20s (인도 여자 20대)",
                "Indian male 30s (인도 남자 30대)",
                "Indian female 30s (인도 여자 30대)",
                "Southeast Asian male 20s (동남아시아 남자 20대)",
                "Southeast Asian female 20s (동남아시아 여자 20대)",
                "Southeast Asian male 30s (동남아시아 남자 30대)",
                "Southeast Asian female 30s (동남아시아 여자 30대)",
                "Latin American male 20s (라틴 아메리카 남자 20대)",
                "Latin American female 20s (라틴 아메리카 여자 20대)",
                "Latin American male 30s (라틴 아메리카 남자 30대)",
                "Latin American female 30s (라틴 아메리카 여자 30대)",
                "Middle Eastern male 30s (중동 남자 30대)",
                "Middle Eastern female 30s (중동 여자 30대)",
                "African male 20s (아프리카 남자 20대)",
                "African female 20s (아프리카 여자 20대)",
                "African male 30s (아프리카 남자 30대)",
                "African female 30s (아프리카 여자 30대)"
            ],
            CHARACTER_4_DETAIL: [],
            CHARACTER_5: [
                "Korean male child (한국 남자 어린이)",
                "Korean female child (한국 여자 어린이)",
                "Korean male teen (한국 남자 청소년)",
                "Korean female teen (한국 여자 청소년)",
                "Korean male 20s (한국 남자 20대)",
                "Korean female 20s (한국 여자 20대)",
                "Korean male 30s (한국 남자 30대)",
                "Korean female 30s (한국 여자 30대)",
                "Korean male 40s (한국 남자 40대)",
                "Korean female 40s (한국 여자 40대)",
                "Korean male 50s (한국 남자 50대)",
                "Korean female 50s (한국 여자 50대)",
                "Korean male 60s (한국 남자 60대)",
                "Korean female 60s (한국 여자 60대)",
                "Korean male 70s+ (한국 남자 70대 이상)",
                "Korean female 70s+ (한국 여자 70대 이상)",
                "Japanese male teen (일본 남자 청소년)",
                "Japanese female teen (일본 여자 청소년)",
                "Japanese male 20s (일본 남자 20대)",
                "Japanese female 20s (일본 여자 20대)",
                "Japanese male 30s (일본 남자 30대)",
                "Japanese female 30s (일본 여자 30대)",
                "Japanese male 40s (일본 남자 40대)",
                "Japanese female 40s (일본 여자 40대)",
                "Chinese male 20s (중국 남자 20대)",
                "Chinese female 20s (중국 여자 20대)",
                "Chinese male 30s (중국 남자 30대)",
                "Chinese female 30s (중국 여자 30대)",
                "Chinese male 40s (중국 남자 40대)",
                "Chinese female 40s (중국 여자 40대)",
                "American male teen (미국 남자 청소년)",
                "American female teen (미국 여자 청소년)",
                "American male 20s (미국 남자 20대)",
                "American female 20s (미국 여자 20대)",
                "American male 30s (미국 남자 30대)",
                "American female 30s (미국 여자 30대)",
                "American male 40s (미국 남자 40대)",
                "American female 40s (미국 여자 40대)",
                "American male 50s (미국 남자 50대)",
                "American female 50s (미국 여자 50대)",
                "European male 20s (유럽 남자 20대)",
                "European female 20s (유럽 여자 20대)",
                "European male 30s (유럽 남자 30대)",
                "European female 30s (유럽 여자 30대)",
                "European male 40s (유럽 남자 40대)",
                "European female 40s (유럽 여자 40대)",
                "British male 30s (영국 남자 30대)",
                "British female 30s (영국 여자 30대)",
                "French male 30s (프랑스 남자 30대)",
                "French female 30s (프랑스 여자 30대)",
                "German male 30s (독일 남자 30대)",
                "German female 30s (독일 여자 30대)",
                "Italian male 30s (이탈리아 남자 30대)",
                "Italian female 30s (이탈리아 여자 30대)",
                "Indian male 20s (인도 남자 20대)",
                "Indian female 20s (인도 여자 20대)",
                "Indian male 30s (인도 남자 30대)",
                "Indian female 30s (인도 여자 30대)",
                "Southeast Asian male 20s (동남아시아 남자 20대)",
                "Southeast Asian female 20s (동남아시아 여자 20대)",
                "Southeast Asian male 30s (동남아시아 남자 30대)",
                "Southeast Asian female 30s (동남아시아 여자 30대)",
                "Latin American male 20s (라틴 아메리카 남자 20대)",
                "Latin American female 20s (라틴 아메리카 여자 20대)",
                "Latin American male 30s (라틴 아메리카 남자 30대)",
                "Latin American female 30s (라틴 아메리카 여자 30대)",
                "Middle Eastern male 30s (중동 남자 30대)",
                "Middle Eastern female 30s (중동 여자 30대)",
                "African male 20s (아프리카 남자 20대)",
                "African female 20s (아프리카 여자 20대)",
                "African male 30s (아프리카 남자 30대)",
                "African female 30s (아프리카 여자 30대)"
            ],
            CHARACTER_5_DETAIL: []
        };
        
        // 드롭다운 값의 한글 번역 매핑
        const dropdownTranslations = {
            // STYLE translations (partial - will expand)
            // Photography / Cinematic
            "Aerial": "항공뷰",
            "Analog": "아날로그",
            "Cinematic": "시네마틱",
            "Documentary": "다큐멘터리",
            "Drone": "드론",
            "HDR": "HDR",
            "High Key": "하이키",
            "Infrared": "적외선",
            "Light Painting": "라이트 페인팅",
            "Lo-fi": "로파이",
            "Low Key": "로우키",
            "Macro": "매크로",
            "Nightscapes": "야경",
            "Noir": "누아르",
            "Photorealistic": "포토리얼리스틱",
            "Polaroid": "폴라로이드",
            "Portrait": "인물 사진",
            "Vintage": "빈티지",
            "Film Noir": "필름 누아르",
            "Anamorphic": "아나모픽",
            "Split Toning": "스플릿 토닝",
            "Film Emulation": "필름 에뮬레이션",
            "Kodak Vision": "코닥 비전",
            "Fujifilm": "후지필름",
            
            // Digital Art
            "3D Render": "3D 렌더",
            "8-bit Art": "8비트 아트",
            "CGI": "CGI",
            "Cyberpunk": "사이버펑크",
            "Digital Painting": "디지털 페인팅",
            "Fractal Art": "프랙탈 아트",
            "Generative Art": "생성 예술",
            "Glitch Art": "글리치 아트",
            "Graffiti Art": "그래피티 아트",
            "Isometric": "아이소메트릭",
            "Low Poly": "로우폴리",
            "Minimalism": "미니멀리즘",
            "Neon Art": "네온 아트",
            "Pixel Art": "픽셀 아트",
            "Ray Tracing": "레이 트레이싱",
            "Vector Art": "벡터 아트",
            "Voxel Art": "복셀 아트",
            "Flat Design": "플랫 디자인",
            "Material Design": "머티리얼 디자인",
            
            // Illustration
            "Anime Style": "애니메이션 스타일",
            "Cartoon": "카툰",
            "Chibi": "치비",
            "Children's Book": "아동 도서 스타일",
            "Comic Book": "코믹북",
            "Concept Art": "컨셉 아트",
            "Disney Style": "디즈니 스타일",
            "Fantasy Illustration": "판타지 일러스트",
            "Graphic Novel": "그래픽 노블",
            "Manga": "만화",
            "Pixar": "픽사 스타일",
            "Studio Ghibli": "스튜디오 지브리",
            "Sketch Style": "스케치 스타일",
            "Papercut Illustration": "페이퍼컷 일러스트",
            "Line Art": "라인 아트",
            "Whimsical": "기발한 스타일",
            "Editorial Illustration": "에디토리얼 일러스트",
            
            // Traditional
            "Acrylic Painting": "아크릴 페인팅",
            "Anatomical Drawing": "해부학 드로잉",
            "Charcoal": "목탄",
            "Chinese Ink Painting": "중국 수묵화",
            "Etching": "에칭",
            "Gouache Painting": "과슈 페인팅",
            "Ink Drawing": "잉크 드로잉",
            "Korean Minhwa": "한국 민화",
            "Oil Painting": "유화",
            "Pastel Drawing": "파스텔 드로잉",
            "Pencil Sketch": "연필 스케치",
            "Persian Miniature": "페르시아 미니어처",
            "Sumi-e": "스미에",
            "Ukiyo-e": "우키요에",
            "Watercolor": "수채화",
            "Fresco": "프레스코",
            "Tempera": "템페라",
            
            // Art Movements
            "Abstract": "추상",
            "Art Deco": "아르데코",
            "Art Nouveau": "아르누보",
            "Baroque": "바로크",
            "Bauhaus": "바우하우스",
            "Brutalism": "브루탈리즘",
            "Cubism": "큐비즘",
            "Dadaism": "다다이즘",
            "Expressionism": "표현주의",
            "Fauvism": "야수파",
            "Gothic": "고딕",
            "Impressionism": "인상주의",
            "Minimalistic": "미니멀리스트",
            "Neo-Expressionism": "신표현주의",
            "Pointillism": "점묘주의",
            "Pop Art": "팝 아트",
            "Renaissance": "르네상스",
            "Rococo": "로코코",
            "Romanticism": "낭만주의",
            "Suprematism": "수프레마티즘",
            "Surrealism": "초현실주의",
            "Symbolism": "상징주의",
            
            // Special / Etc
            "Collage": "콜라주",
            "Dark Fantasy": "다크 판타지",
            "Double Exposure": "다중 노출",
            "Fantasy": "판타지",
            "Horror": "호러",
            "Installation": "설치 미술",
            "Psychedelic": "사이키델릭",
            "Retro": "레트로",
            "Retro-Futurism": "레트로 퓨처리즘",
            "Sacred Geometry": "성스러운 기하학",
            "Sci-Fi": "공상과학",
            "Stained Glass": "스테인드글라스",
            "Steampunk": "스팀펑크",
            "Technical Drawing": "테크니컬 드로잉",
            "Studio Portrait": "스튜디오 인물 사진",
            "Beauty Shot": "뷰티 샷",
            "Fashion Editorial": "패션 에디토리얼",
            "Product Photography": "제품 사진",
            "Street Photography": "스트리트 사진",
            "Architectural Photography": "건축 사진",
            "Landscape": "풍경 사진",
            "Food Photography": "푸드 사진",
            "Still Life": "정물 사진",
            "Y2K Aesthetic": "Y2K 미학",
            "McBling": "맥블링",
            "Dreamcore": "드림코어",
            "Weirdcore": "위어드코어", 
            "Liminal Space": "리미널 스페이스",
            "Dark Academia": "다크 아카데미아",
            "Cottagecore": "코티지코어",
            "Vaporwave": "베이퍼웨이브",
            "Synthwave": "신스웨이브",
            "Webcore": "웹코어",
            "Hyperrealistic": "초현실적인",
            "Hyperdetailed": "초정밀한",
            "Raw Mode": "로우 모드",
            "Draft Mode": "드래프트 모드",
            "Photorealism": "포토리얼리즘",
            
            // MEDIUM translations
            "AI Generated": "AI 생성",
            "Neural Art": "신경망 아트",
            "GAN Art": "GAN 아트",
            "Diffusion Model": "확산 모델",
            "Stable Diffusion": "스테이블 디퓨전",
            "Photorealistic Render": "포토리얼리스틱 렌더",
            "Hyperrealistic CG": "초현실적 CG",
            "Unreal Engine 5": "언리얼 엔진 5",
            "Unity HDRP": "유니티 HDRP",
            "Octane Render": "옥테인 렌더",
            "Redshift Render": "레드시프트 렌더",
            "V-Ray": "V-Ray",
            "Arnold Render": "아놀드 렌더",
            "Cycles Render": "사이클스 렌더",
            "RTX Ray Tracing": "RTX 레이 트레이싱",
            "Oil Painting": "유화",
            "Watercolor": "수채화",
            "Acrylic": "아크릴",
            "Gouache": "과슈",
            "Pencil Drawing": "연필 드로잉",
            "Charcoal": "목탄",
            "Graphite": "흑연",
            "Conte": "콩테",
            "Silverpoint": "실버포인트",
            "Ink Drawing": "잉크 드로잉",
            "Pen and Ink": "펜과 잉크",
            "Pastel": "파스텔",
            "Oil Pastel": "오일 파스텔",
            "Soft Pastel": "소프트 파스텔",
            "Chalk": "분필",
            "Crayon": "크레용",
            "Colored Pencil": "색연필",
            "Digital Photography": "디지털 사진",
            "Film Photography": "필름 사진",
            "35mm Film": "35mm 필름",
            "Medium Format": "중형 포맷",
            "Large Format": "대형 포맷",
            "Instant Photography": "즉석 사진",
            "Daguerreotype": "다게레오타입",
            "Cyanotype": "시아노타입",
            "Tintype": "틴타입",
            "Mixed Media": "혼합 매체",
            "Collage": "콜라주",
            "Digital Collage": "디지털 콜라주",
            "Photo Manipulation": "사진 합성",
            "Photobashing": "포토배싱",
            "3D Sculpture": "3D 조각",
            "Digital Sculpture": "디지털 조각",
            "ZBrush": "ZBrush(제브러시)",
            "Procedural Art": "프로시저럴 아트",
            "Algorithmic Art": "알고리즘 아트",
            "Holography": "홀로그래피",
            "VR Art": "VR 아트",
            "AR Art": "AR 아트",
            "NFT Art": "NFT 아트",
            "Interactive Art": "인터랙티브 아트",
            "Video Art": "비디오 아트",
            "Projection Mapping": "프로젝션 매핑",
            "Light Installation": "라이트 인스톨레이션",
            "Sound Visualization": "사운드 비주얼라이제이션",
            
            // CAMERA translations
            "Eye Level": "눈높이",
            "High Angle": "하이 앵글",
            "Low Angle": "로우 앵글",
            "Dutch Angle": "더치 앵글",
            "Bird's Eye View": "조감도",
            "Worm's Eye View": "개구리 시점",
            "Wide Shot": "와이드 샷",
            "Close-up": "클로즈업",
            "Over the Shoulder": "오버 더 숄더",
            "Point of View (POV)": "주관적 시점",
            "Extreme Wide Shot": "익스트림 와이드 샷",
            "Medium Shot": "미디엄 샷",
            "Medium Close-up": "미디엄 클로즈업",
            "Extreme Close-up": "익스트림 클로즈업",
            "Macro Shot": "매크로 샷",
            "Detail Shot": "디테일 샷",
            "Insert Shot": "인서트 샷",
            "Static Shot": "정지 샷",
            "Pan Left": "좌로 패닝",
            "Pan Right": "우로 패닝",
            "Tilt Up": "틸트 업",
            "Tilt Down": "틸트 다운",
            "Tracking Shot": "트래킹 샷",
            "Dolly In": "돌리 인",
            "Dolly Out": "돌리 아웃",
            "Crane Shot": "크레인 샷",
            "Handheld": "핸드헬드",
            "Gimbal Shot": "짐벌 샷",
            "Reverse Shot": "리버스 샷",
            "Two Shot": "투 샷",
            "Three Shot": "쓰리 샷",
            "Group Shot": "그룹 샷",
            "Establishing Shot": "설정 샷",
            "Master Shot": "마스터 샷",
            "Cutaway": "컷어웨이",
            "Reaction Shot": "리액션 샷",
            "Split Screen": "스플릿 스크린",
            "Match Cut": "매치 컷",
            "Cross-cutting": "크로스 컷팅",
            "Jump Cut": "점프 컷",
            "Whip Pan": "휩 팬",
            "Rack Focus": "랙 포커스",
            "Pull Focus": "풀 포커스",
            "Deep Focus": "딥 포커스",
            "Shallow Focus": "얕은 포커스",
            "Selective Focus": "선택적 포커스",
            "Ultra Wide": "울트라 와이드",
            "Wide Angle": "광각",
            "Standard Lens": "표준 렌즈",
            "Telephoto": "망원",
            "Macro": "매크로",
            "Close-up Portrait": "클로즈업 인물",
            "Headshot": "헤드샷",
            "Full Body Shot": "전신 샷",
            
            // LIGHTING_TECHNIQUE translations
            "Volumetric Lighting": "볼류메트릭 조명",
            "Ray Tracing": "레이 트레이싱",
            "Global Illumination": "글로벌 일루미네이션",
            "Path Tracing": "패스 트레이싱",
            "Subsurface Scattering": "서브서페이스 스캐터링",
            "Rembrandt Lighting": "렘브란트 조명",
            "Golden Hour": "골든 아워",
            "Blue Hour": "블루 아워",
            "Cinematic Lighting": "시네마틱 조명",
            
            // QUALITY translations
            "--q 0.25": "--q 0.25 (빠른 품질)",
            "--q 0.5": "--q 0.5 (중간 품질)",
            "--q 1": "--q 1 (기본 품질)",
            "--q 2": "--q 2 (높은 품질)",
            "--raw": "--raw (로우 모드)",
            "--turbo": "--turbo (터보 모드)",
            "--fast": "--fast (빠른 모드)",
            "--relax": "--relax (릴렉스 모드)",
            "16K": "16K 해상도",
            "8K": "8K 해상도",
            "4K": "4K 해상도",
            "Sharp Focus": "선명한 초점",
            "Soft Focus": "부드러운 초점",
            
            // PARAMETERS translations
            "--v 7": "--v 7 (버전 7)",
            "--ar 16:9": "--ar 16:9 (와이드스크린)",
            "--ar 9:16": "--ar 9:16 (세로형)",
            "--ar 1:1": "--ar 1:1 (정사각형)",
            "--chaos 0": "--chaos 0 (일관성 높음)",
            "--chaos 100": "--chaos 100 (변화 많음)",
            "--stylize 100": "--stylize 100 (스타일 약함)",
            "--stylize 1000": "--stylize 1000 (스타일 강함)",
            "--weird 0": "--weird 0 (일반적)",
            "--weird 3000": "--weird 3000 (매우 독특함)",
            "--style raw": "--style raw (스타일 최소화)",
            
            // COLOR_TONE translations
            "Vibrant Colors": "선명한 색상",
            "Muted Colors": "차분한 색상",
            "Pastel Colors": "파스텔 색상",
            "Neon Colors": "네온 색상",
            "Warm Tones": "따뜻한 톤",
            "Cool Tones": "차가운 톤",
            "Earth Tones": "대지 색조",
            "Monochromatic": "단색",
            "High Contrast": "높은 대비",
            "Low Contrast": "낮은 대비",
            
            // CHARACTER translations
            "Main Character": "주인공",
            "Supporting Character": "조연",
            "Background Character": "배경 인물",
            "Hero": "영웅",
            "Villain": "악당",
            "Mentor": "멘토",
            "Sidekick": "조수",
            "Love Interest": "연인 대상",
            "Comic Relief": "코믹 릴리프",
            "Mysterious Figure": "의문의 인물",
            "Child": "아이",
            "Teenager": "십대",
            "Adult": "성인",
            "Elderly": "노년",
            "Male": "남성",
            "Female": "여성",
            "Non-binary": "논바이너리",
            "Robot": "로봇",
            "Alien": "외계인",

            // BODY_TYPE translations
            "Slim": "슬림",
            "Athletic": "운동형",
            "Muscular": "근육질",
            "Average": "보통 체형",
            "Curvy": "굽이진 체형",
            "Petite": "아담한",
            "Tall": "키 큰",
            "Short": "키 작은",
            "Stocky": "다부진",
            "Lean": "마른 근육질",
            "Bulky": "덩치 큰",
            "Toned": "탄탄한",
            "Soft": "부드러운",
            "Angular": "각진",
            "Round": "둥근",
            "Hourglass": "모래시계형",
            "Pear-shaped": "하체 발달(배형)",
            "V-shaped": "역삼각형",

            // HAIR translations
            "Long": "긴 머리",
            "Short": "짧은 머리",
            "Medium": "중간 길이",
            "Wavy": "웨이브",
            "Straight": "생머리",
            "Curly": "곱슬",
            "Braided": "땋은 머리",
            "Ponytail": "포니테일",
            "Bun": "번 헤어",
            "Pixie Cut": "픽시 컷",
            "Bob Cut": "보브 컷",
            "Undercut": "언더컷",
            "Mohawk": "모히칸",
            "Afro": "아프로",
            "Dreadlocks": "드레드락",
            "Bald": "대머리",
            "Buzz Cut": "버즈 컷",
            "Flowing": "흩날리는",
            "Messy": "헝클어진",
            "Neat": "단정한",
            "Styled": "스타일링",
            "Natural": "내추럴",
            "Colored": "염색",
            "Highlighted": "하이라이트",
            "Ombre": "옴브레",

            // FACE_SHAPE translations
            "Oval": "타원형",
            "Round": "둥근형",
            "Square": "사각형",
            "Heart": "하트형",
            "Diamond": "다이아몬드형",
            "Oblong": "긴형",
            "Triangle": "삼각형",
            "Rectangular": "직사각형",

            // FACIAL_FEATURES translations
            "Sharp": "날카로운",
            "Soft": "부드러운",
            "Angular": "각진",
            "Round": "둥근",
            "Defined": "또렷한",
            "Delicate": "섬세한",
            "Strong": "강한",
            "Gentle": "온화한",
            "Prominent Cheekbones": "도드라진 광대뼈",
            "Dimples": "보조개",
            "Freckles": "주근깨",
            "Beauty Mark": "점(뷰티 마크)",
            "Scar": "흉터",
            "Wrinkles": "주름",
            "Smooth Skin": "매끈한 피부",
            "Beard": "수염",
            "Mustache": "콧수염",
            "Goatee": "염소수염",
            "Clean Shaven": "면도함",
            "Stubble": "수염자국",

            // SKIN translations
            "Fair": "밝은 피부",
            "Light": "연한 피부",
            "Medium": "중간 피부",
            "Tan": "햇볕에 탄 피부",
            "Dark": "짙은 피부",
            "Pale": "창백한 피부",
            "Olive": "올리브 톤",
            "Warm Tone": "웜 톤",
            "Cool Tone": "쿨 톤",
            "Freckled": "주근깨 피부",
            "Clear": "깨끗한 피부",
            "Glowing": "빛나는 피부",
            "Matte": "매트 피부",
            "Dewy": "윤광 피부",
            "Dry": "건성",
            "Oily": "지성",
            "Textured": "결 있는 피부",
            "Smooth": "매끈함",

            // EXPRESSION translations (추가 보강)
            "Neutral": "무표정",
            "Confident": "자신감 있는",
            "Thoughtful": "사색적인",
            "Determined": "결연한",
            "Embarrassed": "당황한",
            "Disappointed": "실망한",

            // CLOTHING translations 보강
            "Jeans and T-shirt": "청바지와 티셔츠",
            "Hoodie": "후디",
            "Jacket": "재킷",
            "Coat": "코트",
            "Sweater": "스웨터",
            "Shorts": "반바지",
            "Skirt": "스커트",

            // ACCESSORIES translations
            "Glasses": "안경",
            "Sunglasses": "선글라스",
            "Hat": "모자",
            "Cap": "캡",
            "Headband": "헤어밴드",
            "Earrings": "귀걸이",
            "Necklace": "목걸이",
            "Bracelet": "팔찌",
            "Ring": "반지",
            "Watch": "시계",
            "Belt": "벨트",
            "Scarf": "스카프",
            "Gloves": "장갑",
            "Bag": "가방",
            "Backpack": "백팩",
            "Jewelry": "주얼리",
            "Tattoo": "문신",
            "Piercing": "피어싱",
            "Mask": "마스크",
            "Crown": "왕관",
            "Tiara": "티아라",
            "Badge": "배지",
            "Pin": "핀",

            // PROPS translations (주요 예시)
            "Weapon": "무기",
            "Tool": "도구",
            "Book": "책",
            "Phone": "전화기",
            "Computer": "컴퓨터",
            "Umbrella": "우산",
            "Cane": "지팡이",
            "Staff": "스태프",
            "Musical Instrument": "악기",
            "Sports Equipment": "스포츠 장비",
            "Food": "음식",
            "Drink": "음료",
            "Flower": "꽃",
            "Key": "열쇠",
            "Map": "지도",
            "Scroll": "두루마리",
            "Crystal": "크리스탈",
            "Orb": "오브",
            "Potion": "물약",
            "Artifact": "유물",
            "Device": "장치",

            // POSE translations (주요 예시)
            "Standing": "서 있는",
            "Sitting": "앉아 있는",
            "Walking": "걷는",
            "Running": "뛰는",
            "Jumping": "점프",
            "Flying": "비행",
            "Fighting": "전투",
            "Dancing": "춤추는",
            "Relaxed": "편안한",
            "Tense": "긴장한",
            "Dynamic": "다이내믹",
            "Static": "정적인",
            "Action Pose": "액션 포즈",
            "Rest Pose": "휴식 포즈",
            "Hero Pose": "영웅 포즈",
            "Dramatic Pose": "드라마틱 포즈",
            "Casual Pose": "캐주얼 포즈",
            "Formal Pose": "포멀 포즈",
            "Combat Stance": "전투 자세",
            "Defensive Stance": "방어 자세",

            // GAZE translations
            "Direct": "정면 응시",
            "Averted": "시선 회피",
            "Downward": "아래쪽 시선",
            "Upward": "위쪽 시선",
            "Side Glance": "옆눈질",
            "Over Shoulder": "어깨 너머 보기",
            "Closed Eyes": "눈 감음",
            "Half-lidded": "반쯤 감은 눈",
            "Wide Open": "크게 뜬 눈",
            "Squinting": "가늘게 뜬 눈",
            "Winking": "윙크",
            "Rolling Eyes": "눈 굴리기",
            "Staring": "응시",
            "Dreamy": "몽환적인 시선",

            // CHARACTER_SHEET translations
            "character turnaround sheet, multiple views, same character, front view and face close-up, same character, detailed view": "입체스트 전신",
            "photo collage of same person, multiple angles, front portrait, side profile, three-quarter view, consistent person": "사진전신",
            "character face sheet, close-up portraits, same character, front face, side profile, 3/4 angle, facial details": "입체스트 얼굴",
            "photo collage of same person's face, close-up shots, front portrait, side profile, three-quarter view, consistent face": "사진 얼굴",
            "character reference sheet, full body shot and portrait close-up, same character, detailed view": "입체스트 혼합",
            "photo reference of same person, full body shot and portrait close-up, consistent person, detailed views": "사진 혼합",
            "character expression sheet, multiple emotions close-up, same character, face happy, sad, angry, surprised, neutral expressions": "입체스트 표정 클로즈업",
            "photo collage of facial expressions, close-up emotions, same person, smiling, crying, laughing, serious, thoughtful faces": "사진 표정 클로즈업",
            "character emotion sheet, full body expressions and poses, same character, happy pose, sad pose, excited pose, tired pose": "입체스트 표정 전신",
            "photo series showing emotions, full body shots, same person, joyful stance, dejected posture, energetic pose, relaxed position": "사진 표정 전신",
            "character reference emotions, full body and face expressions, same character, detailed emotional range": "입체스트 표정 혼합",
            "photo emotion reference sheet, portrait and full body, emotional states, same person, comprehensive mood variations": "사진 표정 혼합",

            "young woman": "젊은 여성",
            "young man": "젊은 남성",
            "middle-aged woman": "중년 여성",
            "middle-aged man": "중년 남성",
            "elderly woman": "노년 여성",
            "elderly man": "노년 남성",
            "teenager": "십대",
            "child": "아이",
            "professional": "전문가",
            "student": "학생",
            "artist": "예술가",
            "scientist": "과학자",
            
            // ATMOSPHERE translations
            "Mysterious": "신비로운",
            "Romantic": "로맨틱한",
            "Peaceful": "평화로운",
            "Chaotic": "혼란스러운",
            "Dreamy": "꿈같은",
            "Realistic": "현실적인",
            "Futuristic": "미래적인",
            "Ancient": "고대의",
            "Liminal": "경계의",
            "Uncanny": "기이한",
            "Vaporwave": "베이퍼웨이브",
            "Cyberpunk": "사이버펑크",
            
            // CLOTHING translations
            "smiling": "웃는",
            "serious": "진지한",
            "thoughtful": "사색적인",
            "confident": "자신감 있는",
            "nervous": "긴장한",
            "excited": "흥분한",
            "calm": "차분한",
            "angry": "화난",
            "sad": "슬픈",
            "happy": "행복한",
            "surprised": "놀란",
            "focused": "집중한",
            "relaxed": "편안한",
            "determined": "결연한",
            "curious": "호기심 있는",
            "worried": "걱정하는",
            "casual clothes": "캐주얼 의상",
            "formal wear": "정장",
            "uniform": "유니폼",
            "traditional dress": "전통 의상",
            "modern fashion": "현대 패션",
            "vintage style": "빈티지 스타일",
            "athletic wear": "운동복",
            "business suit": "비즈니스 정장",
            "streetwear": "스트리트웨어",
            "costume": "코스튬",
            "armor": "갑옷",
            "robe": "로브",
            
            // SCENE translations
            "Daily Life": "일상 생활",
            "Celebration": "축하",
            "Action Scene": "액션 장면",
            "Quiet Moment": "조용한 순간",
            "Romantic Scene": "로맨틱한 장면",
            "Battle Scene": "전투 장면",
            "Peaceful Scene": "평화로운 장면",
            "Dramatic Moment": "극적인 순간",
            
            // LOCATION translations
            "City Street": "도시 거리",
            "Forest": "숲",
            "Beach": "해변",
            "Mountain": "산",
            "Desert": "사막",
            "Ocean": "바다",
            "Lake": "호수",
            "River": "강",
            "Park": "공원",
            "Garden": "정원",
            "Castle": "성",
            "Palace": "궁전",
            
            // WEATHER translations
            "Clear": "맑음",
            "Sunny": "화창함",
            "Cloudy": "흐림",
            "Rainy": "비",
            "Snowy": "눈",
            "Foggy": "안개",
            "Stormy": "폭풍",
            
            // ERA translations
            "Y2K Revival": "Y2K 리바이벌",
            "2000s Nostalgia": "2000년대 향수",
            "McBling Era": "맥블링 시대",
            "Indie Sleaze": "인디 슬리즈",
            "Victorian Era": "빅토리아 시대",
            "Renaissance": "르네상스",
            "Medieval": "중세",
            "Ancient Egypt": "고대 이집트",
            "Cyberpunk 2077": "사이버펑크 2077",
            "Steampunk Victorian": "스팀펑크 빅토리아",
            
            // Additional common terms
            "Ultra Detailed": "초정밀",
            "Highly Detailed": "매우 상세한",
            "Intricate Details": "복잡한 디테일",
            "Fine Details": "세밀한 디테일",
            "High Resolution": "고해상도",
            "Professional": "전문적인",
            "Artistic": "예술적인",
            "Creative": "창의적인",
            "Modern": "현대적인",
            "Classic": "클래식한",
            "Traditional": "전통적인",
            "Contemporary": "동시대의",
            "Futuristic": "미래적인",
            "Vintage": "빈티지",
            "Retro": "레트로"
        };
        
        // 한글 제목 매핑
        const koreanTitles = {
            'STYLE': '스타일',
            'MEDIUM': '매체',
            'ERA/CULTURAL_REF': '시대/문화 참조',
            'CHARACTER': '캐릭터',
            'CAMERA': '카메라',
            'SCENE': '장면',
            'COLOR_TONE': '색조',
            'GAZE': '시선',
            'CHARACTER_SHEET': '캐릭터 시트',
            'BODY_TYPE': '체형',
            'HAIR': '헤어',
            'FACE_SHAPE': '얼굴형',
            'FACIAL_FEATURES': '얼굴 특징',
            'SKIN': '피부',
            'EXPRESSION': '표정',
            'CLOTHING': '의상',
            'ACCESSORIES': '액세서리',
            'PROPS': '소품',
            'POSE': '포즈',
            'BACKGROUND': '배경',
            'LIGHTING': '조명',
            'QUALITY': '품질',
            'PARAMETERS': '파라미터',
            'CHARACTER_1': '캐릭터 1',
            'CHARACTER_1_DETAIL': '캐릭터 1 상세',
            'CHARACTER_2': '캐릭터 2',
            'CHARACTER_2_DETAIL': '캐릭터 2 상세',
            'CHARACTER_3': '캐릭터 3',
            'CHARACTER_3_DETAIL': '캐릭터 3 상세',
            'CHARACTER_4': '캐릭터 4',
            'CHARACTER_4_DETAIL': '캐릭터 4 상세',
            'CHARACTER_5': '캐릭터 5',
            'CHARACTER_5_DETAIL': '캐릭터 5 상세',
            'LOCATION': '장소',
            'LOCATION_DETAIL': '장소 상세',
            'TIME_LIGHTING': '시간대/조명',
            'ARTIFICIAL_LIGHT': '인공 조명',
            'ATMOSPHERE': '분위기',
            'WEATHER': '날씨',
            'FOREGROUND': '전경',
            'CAMERA_EFFECTS': '카메라 효과',
            'LIGHTING_TECHNIQUE': '조명 기법',
            'CAMERA_TECH': '카메라 기술'
        };
        
        const characterCategories = [
                { name: '기본정보', items: [
                    'STYLE', 'MEDIUM', 'CHARACTER', 'CAMERA', 'GAZE', 'CHARACTER_SHEET'
                ]},
                { name: '캐릭터 정보', items: [
                    'BODY_TYPE', 'HAIR', 'FACE_SHAPE', 'FACIAL_FEATURES', 'SKIN', 
                    'EXPRESSION', 'CLOTHING', 'ACCESSORIES', 'PROPS', 'POSE'
                ]},
                { name: '배경/환경 정보', items: [
                    'BACKGROUND'
                ]},
                { name: '기술 정보', items: [
                    'LIGHTING', 'QUALITY', 'PARAMETERS'
                ]}
            ];
            
            // 일반이미지 탭 카테고리
            const generalCategories = {
                '기본정보': ['STYLE', 'MEDIUM', 'ERA/CULTURAL_REF', 'CAMERA', 'SCENE', 'COLOR_TONE'],
                '캐릭터 정보': ['CHARACTER_1', 'CHARACTER_1_DETAIL', 'CHARACTER_2', 'CHARACTER_2_DETAIL', 
                               'CHARACTER_3', 'CHARACTER_3_DETAIL', 'CHARACTER_4', 'CHARACTER_4_DETAIL', 
                               'CHARACTER_5', 'CHARACTER_5_DETAIL'],
                '배경/환경 정보': ['LOCATION', 'LOCATION_DETAIL', 'TIME_LIGHTING', 'ARTIFICIAL_LIGHT',
                                'ATMOSPHERE', 'WEATHER', 'FOREGROUND', 'BACKGROUND'],
                '기술 정보': ['CAMERA_EFFECTS', 'LIGHTING_TECHNIQUE', 'CAMERA_TECH', 'QUALITY', 'PARAMETERS']
            };
            
            if (currentStructureTab === 'character') {
                // 캐릭터 탭: 하위 탭과 함께 표시
                const characterContainer = document.createElement('div');
                characterContainer.className = 'character-container';
                
                // 캐릭터 하위 탭 생성
                const subTabs = document.createElement('div');
                subTabs.className = 'character-sub-tabs';
                subTabs.innerHTML = `
                    <div class="sub-tab-buttons">
                        <button type="button" class="sub-tab-button active" data-category="0" onclick="switchCharacterSubTab(0)">기본정보</button>
                        <button type="button" class="sub-tab-button" data-category="1" onclick="switchCharacterSubTab(1)">캐릭터 정보</button>
                        <button type="button" class="sub-tab-button" data-category="2" onclick="switchCharacterSubTab(2)">배경/환경정보</button>
                        <button type="button" class="sub-tab-button" data-category="3" onclick="switchCharacterSubTab(3)">기술 정보</button>
                    </div>
                `;
                characterContainer.appendChild(subTabs);
                
                // 각 카테고리별 컨텐츠 생성
                const subTabContents = document.createElement('div');
                subTabContents.className = 'sub-tab-contents';
                
                characterCategories.forEach((category, catIndex) => {
                    const content = document.createElement('div');
                    content.className = `sub-tab-content ${catIndex === 0 ? 'active' : ''}`;
                    content.dataset.category = catIndex;
                    
                    let startNumber = 1;
                    if (catIndex === 1) startNumber = 7;  // 캐릭터 정보
                    else if (catIndex === 2) startNumber = 17;  // 배경/환경정보
                    else if (catIndex === 3) startNumber = 18;  // 기술 정보
                    
                    category.items.forEach((key, index) => {
                        const value = structure[key] || '';
                        const itemNumber = startNumber + index;
                        
                        // 드롭다운 컨테이너 생성
                        const dropdownContainer = document.createElement('div');
                        dropdownContainer.className = 'dropdown-container';
                        dropdownContainer.dataset.key = key;
                        
                        dropdownContainer.innerHTML = `
                            <div class="dropdown-header" onclick="toggleDropdown(this.parentElement)">
                                <div class="dropdown-title">
                                    <span class="dropdown-number">${itemNumber}</span>
                                    <span>${koreanTitles[key] || key}</span>
                                    <span class="dropdown-english-label">${key}</span>
                                </div>
                                <span class="dropdown-arrow">▼</span>
                            </div>
                            <div class="dropdown-content">
                                <div class="dropdown-fields">
                                    <div class="dropdown-field">
                                        <label class="dropdown-field-label">기존내용</label>
                                        <input type="text" 
                                               class="dropdown-field-input" 
                                               value="${value}" 
                                               data-key="${key}" 
                                               onchange="updateStructureValue('${key}', this.value)"
                                               placeholder="기존 내용을 입력하세요">
                                    </div>
                                    <div class="dropdown-field">
                                        <div class="dropdown-field-label-with-buttons">
                                            <label class="dropdown-field-label">변경요청${key === 'FACIAL_FEATURES' ? ' <button type="button" class="btn-side-view-warning" onclick="event.stopPropagation(); window.showSideViewWarning();" title="측면 뷰 주의사항">⚠️ 주의</button>' : ''}</label>
                                            <div class="field-action-buttons">
                                                <button type="button" class="btn-field-action btn-save" onclick="saveToApplied(event, '${key}')">저장</button>
                                                <button type="button" class="btn-field-action btn-ai-save" onclick="aiSaveField('${key}')">AI저장</button>
                                            </div>
                                        </div>
                                        <div class="select-input-wrapper">
                                            <input type="text" 
                                                   class="dropdown-field-input with-select" 
                                                   data-key="${key}-request" 
                                                   placeholder="직접 입력 또는 선택">
                                            <button type="button" class="dropdown-toggle-btn" onclick="event.stopPropagation(); toggleStyleDropdown(this)">
                                                <span class="dropdown-icon">▼</span>
                                            </button>
                                            <div class="style-options-dropdown" style="display: none;">
                                                <div class="style-options-search">
                                                    <input type="text" placeholder="검색..." onkeyup="filterStyleDropdown(this)">
                                                </div>
                                                <div class="style-options-list">
                                                    ${(dropdownOptions[key] || []).map((option, idx) => {
                                                        // STYLE 섹션에서는 option이 이미 "English (한글)" 형태
                                                        const isStyleSection = key === 'STYLE';
                                                        const englishValue = isStyleSection ? option.split(' (')[0].trim() : option;
                                                        const displayText = option; // 전체 텍스트 표시
                                                        return `<div class="style-option" role="option" tabindex="-1" data-index="${idx}" data-value="${option}" onclick="event.stopPropagation(); selectStyleOption(this, '${option}', '${key}-request')">${displayText}</div>`;
                                                    }).join('')}
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="dropdown-field">
                                        <label class="dropdown-field-label">변경 반영</label>
                                        <input type="text" 
                                               class="dropdown-field-input" 
                                               data-key="${key}-applied" 
                                               placeholder="변경된 내용을 입력하세요">
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        content.appendChild(dropdownContainer);
                    });
                    
                    subTabContents.appendChild(content);
                });
                
                characterContainer.appendChild(subTabContents);
                promptCardsGrid.appendChild(characterContainer);
                
            } else {
                // 일반이미지 탭: 드롭다운 형태로 변경
                const generalContainer = document.createElement('div');
                generalContainer.className = 'general-container';
                
                // 일반 탭 하위 카테고리 생성
                const subTabs = document.createElement('div');
                subTabs.className = 'character-sub-tabs';
                subTabs.innerHTML = `
                    <div class="sub-tab-buttons">
                        <button type="button" class="sub-tab-button active" data-category="0" onclick="switchGeneralSubTab(0)">기본정보</button>
                        <button type="button" class="sub-tab-button" data-category="1" onclick="switchGeneralSubTab(1)">캐릭터 정보</button>
                        <button type="button" class="sub-tab-button" data-category="2" onclick="switchGeneralSubTab(2)">배경/환경 정보</button>
                        <button type="button" class="sub-tab-button" data-category="3" onclick="switchGeneralSubTab(3)">기술 정보</button>
                    </div>
                `;
                generalContainer.appendChild(subTabs);
                
                // 각 카테고리별 컨텐츠 생성
                const subTabContents = document.createElement('div');
                subTabContents.className = 'sub-tab-contents';

                // 이미지 상의 번호 체계에 맞춘 커스텀 넘버 매핑
                const generalNumberMap = {
                    // 기본정보 (1~6)
                    'STYLE': 1,
                    'MEDIUM': 2,
                    'ERA/CULTURAL_REF': 3,
                    'CAMERA': 4,
                    'SCENE': 5,
                    'COLOR_TONE': 6,
                    // 캐릭터 정보 (6~15) - 이미지 상 표기대로 유지
                    'CHARACTER_1': 6,
                    'CHARACTER_1_DETAIL': 7,
                    'CHARACTER_2': 8,
                    'CHARACTER_2_DETAIL': 9,
                    'CHARACTER_3': 10,
                    'CHARACTER_3_DETAIL': 11,
                    'CHARACTER_4': 12,
                    'CHARACTER_4_DETAIL': 13,
                    'CHARACTER_5': 14,
                    'CHARACTER_5_DETAIL': 15,
                    // 배경/환경 정보 (17~25, 21은 기술 정보에 배정)
                    'LOCATION': 17,
                    'LOCATION_DETAIL': 18,
                    'TIME_LIGHTING': 19,
                    'ARTIFICIAL_LIGHT': 20,
                    'ATMOSPHERE': 22,
                    'WEATHER': 23,
                    'FOREGROUND': 24,
                    'BACKGROUND': 25,
                    // 기술 정보 (16, 21, 27, 28, 29)
                    'CAMERA_EFFECTS': 16,
                    'LIGHTING_TECHNIQUE': 21,
                    'CAMERA_TECH': 27,
                    'QUALITY': 28,
                    'PARAMETERS': 29
                };
                
                const generalCategoriesArray = [
                    { name: '기본정보', items: generalCategories['기본정보'] },
                    { name: '캐릭터 정보', items: generalCategories['캐릭터 정보'] },
                    { name: '배경/환경 정보', items: generalCategories['배경/환경 정보'] },
                    { name: '기술 정보', items: generalCategories['기술 정보'] }
                ];
                
                generalCategoriesArray.forEach((category, catIndex) => {
                    const content = document.createElement('div');
                    content.className = `sub-tab-content ${catIndex === 0 ? 'active' : ''}`;
                    content.dataset.category = catIndex;
                    
                    // 기본 시작 번호 (커스텀 매핑이 없는 항목 대비용)
                    let startNumber = 1;
                    if (catIndex === 1) startNumber = 7;
                    else if (catIndex === 2) startNumber = 17;
                    else if (catIndex === 3) startNumber = 16;
                    
                    category.items.forEach((key, index) => {
                        const value = structure[key] || '';
                        const itemNumber = generalNumberMap[key] ?? (startNumber + index);
                        
                        // 드롭다운 컨테이너 생성
                        const dropdownContainer = document.createElement('div');
                        dropdownContainer.className = 'dropdown-container';
                        dropdownContainer.dataset.key = key;
                        
                        dropdownContainer.innerHTML = `
                            <div class="dropdown-header" onclick="toggleDropdown(this.parentElement)">
                                <div class="dropdown-title">
                                    <span class="dropdown-number">${itemNumber}</span>
                                    <span>${koreanTitles[key] || key}</span>
                                    <span class="dropdown-english-label">${key}</span>
                                </div>
                                <span class="dropdown-arrow">▼</span>
                            </div>
                            <div class="dropdown-content">
                                <div class="dropdown-fields">
                                    <div class="dropdown-field">
                                        <label class="dropdown-field-label">기존내용</label>
                                        <input type="text" 
                                               class="dropdown-field-input" 
                                               value="${value}" 
                                               data-key="${key}" 
                                               onchange="updateStructureValue('${key}', this.value)"
                                               placeholder="기존 내용을 입력하세요">
                                    </div>
                                    <div class="dropdown-field">
                                        <div class="dropdown-field-label-with-buttons">
                                            <label class="dropdown-field-label">변경요청${key === 'FACIAL_FEATURES' ? ' <button type="button" class="btn-side-view-warning" onclick="event.stopPropagation(); window.showSideViewWarning();" title="측면 뷰 주의사항">⚠️ 주의</button>' : ''}</label>
                                            <div class="field-action-buttons">
                                                <button type="button" class="btn-field-action btn-save" onclick="saveToApplied(event, '${key}')">저장</button>
                                                <button type="button" class="btn-field-action btn-ai-save" onclick="aiSaveField('${key}')">AI저장</button>
                                            </div>
                                        </div>
                                        ${// 드롭다운 없이 일반 입력창만 표시하는 필드들
                                        (key === 'CHARACTER_1_DETAIL' || key === 'CHARACTER_2_DETAIL' || 
                                         key === 'CHARACTER_3_DETAIL' || key === 'CHARACTER_4_DETAIL' || 
                                         key === 'CHARACTER_5_DETAIL' || key === 'SCENE' || 
                                         key === 'LOCATION_DETAIL' || key === 'FOREGROUND' || 
                                         key === 'BACKGROUND' || key === 'CAMERA_TECH') ?
                                        `<input type="text" 
                                               class="dropdown-field-input" 
                                               data-key="${key}-request" 
                                               placeholder="직접 입력만 가능합니다">` :
                                        `<div class="select-input-wrapper">
                                            <input type="text" 
                                                   class="dropdown-field-input with-select" 
                                                   data-key="${key}-request" 
                                                   placeholder="직접 입력 또는 선택">
                                            <button type="button" class="dropdown-toggle-btn" onclick="event.stopPropagation(); toggleStyleDropdown(this)">
                                                <span class="dropdown-icon">▼</span>
                                            </button>
                                            <div class="style-options-dropdown" style="display: none;">
                                                <div class="style-options-search">
                                                    <input type="text" placeholder="검색..." onkeyup="filterStyleDropdown(this)">
                                                </div>
                                                <div class="style-options-list">
                                                    ${(dropdownOptions[key] || []).map((option, idx) => {
                                                        // STYLE 섹션에서는 option이 이미 "English (한글)" 형태
                                                        const isStyleSection = key === 'STYLE';
                                                        const englishValue = isStyleSection ? option.split(' (')[0].trim() : option;
                                                        const displayText = option; // 전체 텍스트 표시
                                                        return `<div class="style-option" role="option" tabindex="-1" data-index="${idx}" data-value="${option}" onclick="event.stopPropagation(); selectStyleOption(this, '${option}', '${key}-request')">${displayText}</div>`;
                                                    }).join('')}
                                                </div>
                                            </div>
                                        </div>`
                                        }
                                    </div>
                                    <div class="dropdown-field">
                                        <label class="dropdown-field-label">변경 반영</label>
                                        <input type="text" 
                                               class="dropdown-field-input" 
                                               data-key="${key}-applied" 
                                               placeholder="변경된 내용을 입력하세요">
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        content.appendChild(dropdownContainer);
                    });
                    
                    subTabContents.appendChild(content);
                });
                
                generalContainer.appendChild(subTabContents);
                promptCardsGrid.appendChild(generalContainer);
            }
            
            // 일반이미지 탭: '기타' 섹션은 생성하지 않음 (요청에 따라 제거)
            
            promptCardsSection.style.display = 'block';
        }

        // 카드 편집 함수
        function editCard(key) {
            const card = document.querySelector(`.prompt-card[data-key="${key}"]`);
            card.classList.add('editing');
            const input = card.querySelector('.prompt-card-input');
            input.focus();
            input.setSelectionRange(input.value.length, input.value.length);
        }

        // 카드 저장 함수
        function saveCard(key) {
            const card = document.querySelector(`.prompt-card[data-key="${key}"]`);
            const input = card.querySelector('.prompt-card-input');
            const content = card.querySelector('.prompt-card-content');
            
            promptData.structuredPrompt[key] = input.value;
            content.textContent = input.value;
            card.classList.remove('editing');
            
            // 사용자가 프롬프트 입력창을 편집 중이 아닐 때만 업데이트
            if (!userEditingPreview) {
                updatePromptPreview();
            }
            saveToLocalStorage();
        }

        // 카드 취소 함수
        function cancelCard(key) {
            const card = document.querySelector(`.prompt-card[data-key="${key}"]`);
            const input = card.querySelector('.prompt-card-input');
            
            input.value = promptData.structuredPrompt[key];
            card.classList.remove('editing');
        }

        // 최종 프롬프트 복사

        // 최종 프롬프트 복사
        copyFinalPromptBtn.addEventListener('click', () => {
            const value = finalPromptText.value || '';
            if (!value.trim()) {
                showToast('복사할 최종 프롬프트가 없습니다.', 'error');
                return;
            }
            navigator.clipboard.writeText(value)
                .then(() => showToast('최종 프롬프트가 복사되었습니다.', 'success'))
                .catch(() => showToast('복사에 실패했습니다.', 'error'));
        });

        // AI 연동 버튼
        aiConnectBtn.addEventListener('click', () => {
            openApiModal();
        });

        // 토스트 메시지 표시 - 콘솔 로그로 대체
        function showToast(message, type = 'success') {
            // 콘솔에 로그 출력
            if (type === 'error') {
                console.error(`[ERROR] ${message}`);
            } else if (type === 'warning') {
                console.warn(`[WARNING] ${message}`);
            } else {
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
            
            // 중요한 에러는 alert로 표시
            if (type === 'error' && message.includes('API')) {
                alert(message);
            }
        }

        // 로컬 스토리지 저장
        function saveToLocalStorage() {
            localStorage.setItem('imagePromptData', JSON.stringify(promptData));
        }

        // 로컬 스토리지에서 불러오기
        function loadFromLocalStorage() {
            const saved = localStorage.getItem('imagePromptData');
            if (saved) {
                promptData = JSON.parse(saved);
                
                // 텍스트 복원
                if (promptData.textInput) {
                    promptPreview.textContent = promptData.textInput;
                    promptPreview.classList.add('has-content');
                }
                
            }
        }

        // 프롬프트 미리보기 업데이트 함수
        function updatePromptPreview(forceUpdate = false) {
            // 사용자가 직접 편집 중이면서 강제 업데이트가 아닌 경우 업데이트 스킵
            if (userEditingPreview && !forceUpdate) {
                console.log('사용자 편집 모드 - 프롬프트 미리보기 업데이트 스킵');
                return;
            }
            
            const text = promptData.textInput || promptPreview.innerText.trim();
            
                if (!text && Object.keys(promptData.structuredPrompt).length === 0) {
                    if (!userEditingPreview) {
                        promptPreview.innerHTML = '';
                    }
                    promptPreview.classList.remove('has-content');
                    promptCardsSection.style.display = 'none';
                    return;
                }

            let previewText = '';
            
            // 구조화된 프롬프트가 있으면 우선 사용 (줄바꿈 포맷)
            if (Object.keys(promptData.structuredPrompt).length > 0) {
                previewText = structureToMultilineText(promptData.structuredPrompt);
            } else if (text) {
                // 텍스트 기반 프롬프트 미리보기
                previewText = enhancePrompt(text);
                
                // 구조화된 프롬프트인지 확인하고 파싱
                if (text.includes(':') && text.includes(';')) {
                    promptData.structuredPrompt = parsePrompt(text);
                    createPromptCards(promptData.structuredPrompt);
                    // 구조로 인식되면 줄바꿈 포맷으로 표시
                    previewText = structureToMultilineText(promptData.structuredPrompt);
                } else {
                    promptCardsSection.style.display = 'none';
                }
            }
            

            if (!userEditingPreview) {
                promptPreview.textContent = previewText;
            }
            promptPreview.classList.add('has-content');
        }

        // 프롬프트 미리보기 직접 편집 기능
        promptPreview.addEventListener('input', () => {
            const text = promptPreview.innerText.trim();
            promptData.textInput = text;
            
            // 구조화된 프롬프트인 경우 자동으로 파싱
            if (text.includes(':') && text.includes(';')) {
                promptData.structuredPrompt = parsePrompt(text);
                createPromptCards(promptData.structuredPrompt);
                promptCardsSection.style.display = 'block';
            }
            
            saveToLocalStorage();
        });

        // 페이지 로드 시 데이터 복원
        window.addEventListener('load', () => {
            loadFromLocalStorage();
            
            // localStorage에 데이터가 없으면 placeholder만 표시
            if (!promptData.textInput && !localStorage.getItem('imagePromptData')) {
                // 기본값 설정 제거 - 사용자가 예시 프롬프트 버튼을 클릭해야만 로드
            }
            
            // AI 수정을 위해 전달받은 프롬프트가 있는지 확인
            const aiEditPrompt = localStorage.getItem('aiEditPrompt');
            if (aiEditPrompt) {
                // 프롬프트를 입력창에 설정
                promptPreview.textContent = aiEditPrompt;
                promptPreview.classList.add('has-content');
                userEditingPreview = true;
                
                // promptData 업데이트
                promptData.textInput = aiEditPrompt;
                
                // 구조화된 프롬프트인 경우 자동 파싱
                if (aiEditPrompt.includes(':') && (aiEditPrompt.includes(';') || aiEditPrompt.includes('\n'))) {
                    const parsedStructure = parsePrompt(aiEditPrompt);
                    if (Object.keys(parsedStructure).length > 0) {
                        promptData.structuredPrompt = parsedStructure;
                        createPromptCards(parsedStructure);
                        promptCardsSection.style.display = 'block';
                    }
                }
                
                // 사용 후 localStorage에서 제거
                localStorage.removeItem('aiEditPrompt');
                
                // 토스트 메시지 표시
                showToast('프롬프트를 가져왔습니다.', 'success');
            }
            
            // 프롬프트 미리보기에 기본값이 있으면 확인
            if (promptData.textInput) {
                // 구조화된 프롬프트인 경우 자동으로 파싱하여 카드 생성
                const text = promptData.textInput;
                if (text.includes(':') && text.includes(';')) {
                    promptData.structuredPrompt = parsePrompt(text);
                    createPromptCards(promptData.structuredPrompt);
                }
            }
            
            // 구조 편집기 탭을 기본적으로 표시
            const hasStructuredData = Object.keys(promptData.structuredPrompt).length > 0;
            if (hasStructuredData) {
                // 저장된 구조화 데이터가 있으면 카드 생성
                createPromptCards(promptData.structuredPrompt);
            } else {
                // 구조화 데이터가 없으면 기본 템플릿으로 초기화
                const characterTemplate = {
                    'STYLE': '',
                    'MEDIUM': '',
                    'CHARACTER': '',
                    'CAMERA': '',
                    'GAZE': '',
                    'CHARACTER_SHEET': ''
                };
                promptData.structuredPrompt = characterTemplate;
                createPromptCards(characterTemplate);
            }
            promptCardsSection.style.display = 'block';
            
            updatePromptPreview();

            // 프리뷰 직접 입력 제어
            promptPreview.addEventListener('focus', () => {
                userEditingPreview = true;
                // placeholder 텍스트 제거
                const placeholder = promptPreview.querySelector('.preview-placeholder');
                if (placeholder) {
                    promptPreview.innerHTML = '';
                }
            });
            promptPreview.addEventListener('input', () => {
                userEditingPreview = true;
                // placeholder가 있으면 제거
                const placeholder = promptPreview.querySelector('.preview-placeholder');
                if (placeholder) {
                    placeholder.remove();
                }
            });
            promptPreview.addEventListener('blur', () => {
                const manualText = (promptPreview.textContent || '').trim();
                // 사용자가 내용을 입력했으면 편집 모드 유지
                if (manualText) {
                    userEditingPreview = true;
                } else {
                    userEditingPreview = false;
                    // 비워졌으면 상태 초기화 후 자동 미리보기 복구
                    promptData.structuredPrompt = {};
                    updatePromptPreview();
                            return;
                }
                    if (manualText.includes(':') && (manualText.includes(';') || manualText.includes('\n'))) {
                    // 구조화 텍스트로 해석 (세미콜론 또는 줄바꿈 형식)
                    promptData.structuredPrompt = parsePrompt(manualText);
                    createPromptCards(promptData.structuredPrompt);
                    promptCardsSection.style.display = 'block';
                } else {
                    // 구조화 아님 → 카드 숨김, 텍스트만 유지
                    promptData.structuredPrompt = {};
                    promptCardsSection.style.display = 'none';
                }
                saveToLocalStorage();
            });
        });

        // 카드 입력창 키보드 이벤트 처리
        function handleCardKeydown(event, key) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                saveCard(key);
            } else if (event.key === 'Escape') {
                event.preventDefault();
                cancelCard(key);
            }
        }

        // 프롬프트 가져오기 함수
        function importPromptFromPreview() {
            const previewText = promptPreview.textContent;
            // 세미콜론 형식 또는 줄바꿈 형식 모두 구조화된 것으로 인식
            const hasStructured = !!previewText && previewText.includes(':') && 
                                (previewText.includes(';') || previewText.includes('\n'));

            // 프리뷰가 비었거나 구조화되지 않은 경우: 현재 구조 편집기 탭의 템플릿 사용
            if (!previewText || previewText.trim() === '' || !hasStructured) {
                const characterTemplate = {
                    'STYLE': 'professional portrait photography',
                    'MEDIUM': 'high quality photography',
                    'CHARACTER': 'Korean male 28',
                    'CAMERA': 'close-up shot, multiple angles',
                    'CHARACTER_SHEET': 'photo collage of same person, close-up portraits, front face, side profile, 3/4 angle, consistent person',
                    'BODY_TYPE': 'average build, 175cm',
                    'HAIR': 'black short neat side part',
                    'FACE_SHAPE': 'oval',
                    'FACIAL_FEATURES': 'straight eyebrows, dark brown almond eyes, medium nose, natural lips',
                    'SKIN': 'light beige smooth',
                    'EXPRESSION': 'neutral calm',
                    'GAZE': 'varied eye directions for each angle',
                    'CLOTHING': 'navy blue casual t-shirt',
                    'BACKGROUND': 'white background',
                    'LIGHTING': 'professional portrait lighting',
                    'QUALITY': 'high-end photography',
                    'PARAMETERS': '--ar 16:9 --v 6'
                };

                const generalTemplate = {
                    'STYLE': 'cinematic photography',
                    'MEDIUM': 'digital photography',
                    'ERA/CULTURAL_REF': '(선택)',
                    'CAMERA': 'wide shot, low angle',
                    'SCENE': 'two people talking in car during chase',
                    'CHARACTER_1': 'young woman driving, tense expression',
                    'CHARACTER_1_DETAIL': 'ponytail, leather jacket',
                    'CHARACTER_2': 'man in passenger seat, looking back',
                    'CHARACTER_2_DETAIL': 'stubble, white shirt',
                    'CHARACTER_3': '(선택)',
                    'CHARACTER_3_DETAIL': '(선택)',
                    'CHARACTER_4': '(선택)',
                    'CHARACTER_4_DETAIL': '(선택)',
                    'CHARACTER_5': '(선택)',
                    'CHARACTER_5_DETAIL': '(선택)',
                    'CAMERA_EFFECTS': 'motion blur, shallow DOF',
                    'LOCATION': 'city highway at rush hour',
                    'LOCATION_DETAIL': 'inside sedan, leather seats',
                    'TIME_LIGHTING': 'golden hour sunlight',
                    'ARTIFICIAL_LIGHT': 'dashboard glow, street lights',
                    'LIGHTING_TECHNIQUE': 'backlit silhouettes',
                    'ATMOSPHERE': 'tense, urgent',
                    'WEATHER': 'clear',
                    'FOREGROUND': 'dashboard',
                    'BACKGROUND': 'blurred city skyline',
                    'COLOR_TONE': 'warm oranges, deep shadows',
                    'CAMERA_TECH': 'Canon 5D, 24mm lens, f/2.8 (선택)',
                    'QUALITY': 'photorealistic',
                    'PARAMETERS': '--ar 16:9 --v 7'
                };

                const chosen = currentStructureTab === 'character' ? characterTemplate : generalTemplate;
                promptData.structuredPrompt = chosen;
                createPromptCards(chosen);
                promptCardsSection.style.display = 'block';
                // 프리뷰는 사용자가 보고 있는 내용을 보존하기 위해 즉시 갱신하지 않음
                showToast('템플릿을 구조 편집기로 가져왔습니다. 각 항목을 편집하세요.', 'success');
                return;
            }

            // 프리뷰가 구조화된 경우: 프리뷰를 파싱하여 카드 생성
            const parsed = parsePrompt(previewText);
            console.log('가져오기: 파싱된 구조', parsed);
            
            // 파싱된 키를 기반으로 어떤 탭을 사용할지 자동 감지
            const hasCharacterKeys = ['CHARACTER_SHEET', 'BODY_TYPE', 'HAIR', 'FACE_SHAPE', 'FACIAL_FEATURES', 'SKIN', 'EXPRESSION', 'GAZE'].some(key => parsed[key]);
            const hasGeneralKeys = ['SCENE', 'LOCATION', 'LOCATION_DETAIL', 'TIME_LIGHTING', 'ARTIFICIAL_LIGHT', 'ATMOSPHERE', 'WEATHER', 'FOREGROUND', 'BACKGROUND'].some(key => parsed[key]);
            
            // 자동 탭 전환 우선순위: 캐릭터 > 일반이미지 > 유지
            if (hasCharacterKeys) {
                // 캐릭터 관련 키가 하나라도 있으면 캐릭터 탭으로
                switchStructureTab('character');
            } else if (hasGeneralKeys) {
                // 캐릭터 키가 없고 일반 키가 있으면 일반이미지 탭으로
                switchStructureTab('general');
            }
            // 둘 다 없으면 현재 탭 유지
            
            const defaultKeys = ['STYLE', 'MEDIUM', 'CAMERA', 'SUBJECT', 'CHARACTER', 'FURNITURE', 'PROPS', 'AI ROBOTS', 'LIGHTING', 'ENVIRONMENT', 'ATMOSPHERE', 'QUALITY', 'PARAMETERS'];
            const structuredData = {};
            defaultKeys.forEach(key => { structuredData[key] = parsed[key] || ''; });
            Object.keys(parsed).forEach(key => { if (!defaultKeys.includes(key)) { structuredData[key] = parsed[key]; } });
            promptData.structuredPrompt = structuredData;
            createPromptCards(structuredData);
            promptCardsSection.style.display = 'block';
            // 프리뷰는 즉시 갱신하지 않음 (사용자 입력 보호)
            showToast('프롬프트를 구조 편집기로 가져왔습니다.', 'success');
        }

        // 캐릭터 테이블 값 업데이트 함수
        function updateStructureValue(key, value) {
            promptData.structuredPrompt[key] = value;
            saveToLocalStorage();
            
            // 프롬프트 미리보기 업데이트
            if (!userEditingPreview) {
                const multilineText = structureToMultilineText(promptData.structuredPrompt);
                promptPreview.textContent = multilineText;
            }
        }
        
        // 드롭다운 토글 함수 (하나만 열림 유지)
        function toggleDropdown(container) {
            // 이미 열려있는 다른 컨테이너 모두 닫기
            document.querySelectorAll('.dropdown-container.active').forEach((open) => {
                if (open !== container) {
                    open.classList.remove('active');
                }
            });
            // 현재 컨테이너 토글
            container.classList.toggle('active');
        }
        
        // 스타일 드롭다운 토글
        function toggleStyleDropdown(button) {
            event.stopPropagation();
            event.preventDefault();
            
            const wrapper = button.closest('.select-input-wrapper');
            const dropdown = wrapper.querySelector('.style-options-dropdown');
            const isOpen = dropdown.style.display !== 'none';
            
            // 모든 열린 드롭다운 닫기
            closeAllDropdowns();
            
            if (!isOpen) {
                // 드롭다운 열기
                dropdown.style.display = 'flex';
                button.classList.add('active');
                activeDropdown = dropdown;
                currentFocusedIndex = -1;
                
                // ARIA 속성 설정
                button.setAttribute('aria-expanded', 'true');
                dropdown.setAttribute('role', 'listbox');
                
                // 드롭다운 선택 상태 초기화
                if (!wrapper.dropdownSelections) {
                    wrapper.dropdownSelections = [];
                }
                
                // 현재 입력값에서 드롭다운 옵션에 해당하는 값들 찾기
                const input = wrapper.querySelector('.dropdown-field-input');
                const currentValues = input.value.trim() ? input.value.split(',').map(v => v.trim()).filter(v => v) : [];
                const options = dropdown.querySelectorAll('.style-option');
                
                // 필드 키 확인 (PARAMETERS 필드인지)
                const inputKey = input.getAttribute('data-key');
                const key = inputKey ? inputKey.replace('-request', '') : '';
                const isParametersField = key === 'PARAMETERS';
                
                // 드롭다운 선택 상태 업데이트
                wrapper.dropdownSelections = [];
                options.forEach(option => {
                    const optionFullText = option.getAttribute('data-value') || option.textContent.trim();
                    
                    // 옵션 값 처리 - PARAMETERS 필드는 앞 부분만, 나머지는 영문명만
                    let optionValue;
                    if (isParametersField && optionFullText.includes(' - ')) {
                        // PARAMETERS 필드에서는 - 앞 부분만 추출
                        optionValue = optionFullText.split(' - ')[0].trim();
                    } else {
                        // 다른 필드에서는 영문명만 추출 (괄호 앞부분만)
                        optionValue = optionFullText.split(' (')[0].trim();
                    }
                    
                    // 현재 입력값에 해당 값이 포함되어 있는지 확인
                    if (currentValues.includes(optionValue)) {
                        option.classList.add('selected');
                        wrapper.dropdownSelections.push(optionValue);
                    } else {
                        option.classList.remove('selected');
                    }
                });
                
                // 검색 입력창에 포커스
                setTimeout(() => {
                    const searchInput = dropdown.querySelector('.style-options-search input');
                    searchInput.focus();
                    
                    // 키보드 이벤트 리스너 추가
                    addKeyboardListeners(dropdown, wrapper);
                    
                    // 드롭다운이 화면에 보이도록 위치 조정 및 스크롤
                    const dropdownRect = dropdown.getBoundingClientRect();
                    const windowHeight = window.innerHeight;
                    const inputRect = wrapper.getBoundingClientRect();
                    
                    // 드롭다운은 항상 아래로만 열리게 고정하고, 화면 밖이면 스크롤로 보이게 함
                    dropdown.style.top = 'calc(100% + 4px)';
                    dropdown.style.bottom = 'auto';
                    if (dropdownRect.bottom > windowHeight - 20) {
                        const scrollAmount = dropdownRect.bottom - windowHeight + 50; // 50px 여유
                        window.scrollBy({ top: scrollAmount, behavior: 'smooth' });
                    }
                    
                    // 드롭다운 내부 클릭 이벤트 전파 차단
                    dropdown.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                }, 50);
            }
        }
        
        // 스타일 옵션 선택 (다중 선택 지원)
        function selectStyleOption(element, value, inputKey) {
            event.stopPropagation();
            event.preventDefault();
            
            const wrapper = element.closest('.select-input-wrapper');
            const input = wrapper.querySelector('.dropdown-field-input');
            
            // 필드 키 확인 (PARAMETERS 필드인지)
            const key = inputKey.replace('-request', '');
            const isParametersField = key === 'PARAMETERS';
            
            // value 처리 - PARAMETERS 필드는 앞 부분만, 나머지는 전체
            let displayValue;
            if (isParametersField && value.includes(' - ')) {
                // PARAMETERS 필드에서는 - 앞 부분만 추출
                displayValue = value.split(' - ')[0].trim();
            } else {
                // 다른 필드에서는 영문명만 추출 (괄호 앞부분만)
                displayValue = value.split(' (')[0].trim();
            }
            
            // 현재 입력값을 배열로 변환 (쉼표로 구분)
            let currentValues = input.value.trim() ? input.value.split(',').map(v => v.trim()).filter(v => v) : [];
            
            // 드롭다운에서 선택된 값들만 관리하기 위한 데이터 속성
            if (!wrapper.dropdownSelections) {
                wrapper.dropdownSelections = [];
            }
            
            // 이미 드롭다운에서 선택된 값인지 확인
            const dropdownIndex = wrapper.dropdownSelections.indexOf(displayValue);
            
            if (dropdownIndex > -1) {
                // 이미 선택된 경우 제거 (토글)
                wrapper.dropdownSelections.splice(dropdownIndex, 1);
                element.classList.remove('selected');
                
                // 전체 값에서도 제거
                const valueIndex = currentValues.indexOf(displayValue);
                if (valueIndex > -1) {
                    currentValues.splice(valueIndex, 1);
                }
            } else {
                // 선택되지 않은 경우 추가
                wrapper.dropdownSelections.push(displayValue);
                element.classList.add('selected');
                
                // 전체 값에 추가 (중복 확인)
                if (!currentValues.includes(displayValue)) {
                    currentValues.push(displayValue);
                }
            }
            
            // 입력 필드에 업데이트
            input.value = currentValues.join(', ');
            input.dispatchEvent(new Event('change'));
            
            // 구조 데이터 업데이트
            updateStructureValue(key, input.value);
            
            // 드롭다운은 열어둠 (다중 선택을 위해)
        }
        
        // 스타일 드롭다운 필터링
        function filterStyleDropdown(searchInput) {
            const searchValue = searchInput.value.toLowerCase();
            const dropdown = searchInput.closest('.style-options-dropdown');
            const options = dropdown.querySelectorAll('.style-option');
            
            options.forEach(option => {
                const text = option.textContent.toLowerCase();
                if (text.includes(searchValue)) {
                    option.classList.remove('hidden');
                } else {
                    option.classList.add('hidden');
                }
            });
        }
        
        // 입력 필드에서 필터링
        function filterStyleOptions(input) {
            const searchValue = input.value.toLowerCase();
            const wrapper = input.closest('.select-input-wrapper');
            const dropdown = wrapper.querySelector('.style-options-dropdown');
            const options = dropdown.querySelectorAll('.style-option');
            
            options.forEach(option => {
                const text = option.textContent.toLowerCase();
                if (text.includes(searchValue)) {
                    option.classList.remove('hidden');
                } else {
                    option.classList.add('hidden');
                }
            });
        }
        
        // 모든 드롭다운 닫기
        function closeAllDropdowns() {
            document.querySelectorAll('.style-options-dropdown').forEach(dropdown => {
                const button = dropdown.parentElement.querySelector('.dropdown-toggle-btn');
                closeDropdown(dropdown, button);
            });
            activeDropdown = null;
            currentFocusedIndex = -1;
        }
        
        // 특정 드롭다운 닫기
        function closeDropdown(dropdown, button) {
            dropdown.style.display = 'none';
            button.classList.remove('active');
            button.setAttribute('aria-expanded', 'false');
            
            // 포커스된 옵션 스타일 제거
            dropdown.querySelectorAll('.style-option').forEach(option => {
                option.classList.remove('focused');
            });
            
            // 드롭다운 위치 초기화 (항상 아래로)
            dropdown.style.bottom = 'auto';
            dropdown.style.top = 'calc(100% + 4px)';
        }
        
        // 키보드 이벤트 리스너 추가
        function addKeyboardListeners(dropdown, wrapper) {
            const searchInput = dropdown.querySelector('.style-options-search input');
            const input = wrapper.querySelector('.dropdown-field-input');
            
            // 검색 입력창 키보드 이벤트
            searchInput.addEventListener('keydown', (e) => {
                handleDropdownKeyboard(e, dropdown, wrapper);
            });
            
            // 드롭다운 전체 키보드 이벤트
            dropdown.addEventListener('keydown', (e) => {
                handleDropdownKeyboard(e, dropdown, wrapper);
            });
        }
        
        // 드롭다운 키보드 핸들러
        function handleDropdownKeyboard(e, dropdown, wrapper) {
            const options = Array.from(dropdown.querySelectorAll('.style-option:not(.hidden)'));
            const button = wrapper.querySelector('.dropdown-toggle-btn');
            
            switch(e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    currentFocusedIndex = Math.min(currentFocusedIndex + 1, options.length - 1);
                    updateFocusedOption(options);
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    currentFocusedIndex = Math.max(currentFocusedIndex - 1, -1);
                    updateFocusedOption(options);
                    break;
                    
                case 'Enter':
                    e.preventDefault();
                    if (currentFocusedIndex >= 0 && options[currentFocusedIndex]) {
                        options[currentFocusedIndex].click();
                    }
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    closeDropdown(dropdown, button);
                    wrapper.querySelector('.dropdown-field-input').focus();
                    break;
                    
                case 'Tab':
                    // Tab 키는 드롭다운을 닫고 다음 요소로 이동
                    e.preventDefault();
                    closeDropdown(dropdown, button);
                    break;
            }
        }
        
        // 포커스된 옵션 업데이트
        function updateFocusedOption(options) {
            options.forEach((option, index) => {
                if (index === currentFocusedIndex) {
                    option.classList.add('focused');
                    option.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                } else {
                    option.classList.remove('focused');
                }
            });
        }
        
        // 클릭 외부 영역 처리
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.select-input-wrapper')) {
                closeAllDropdowns();
            }
        });
        
        // 저장 버튼 클릭 시 변경요청 값을 변경반영으로 복사
        function saveToApplied(event, key) {
            // 저장 버튼을 클릭한 드롭다운 컨테이너 찾기
            const button = event.target;
            let container = button.closest('.dropdown-container');
            
            if (!container) {
                // 키로 직접 찾거나, 활성 컨테이너로 대체
                container = document.querySelector(`.dropdown-container[data-key="${key}"]`) ||
                            document.querySelector('.dropdown-container.active');
                if (!container) {
                    showToast('드롭다운을 먼저 열어주세요.', 'error');
                    return;
                }
            }
            
            const requestInput = container.querySelector(`input[data-key="${key}-request"]`);
            const appliedInput = container.querySelector(`input[data-key="${key}-applied"]`);
            const existingInput = container.querySelector(`input[data-key="${key}"]`);
            
            if (!appliedInput) return;
            
            const requestValue = (requestInput?.value || '').trim();
            let valueToApply = requestValue;
            
            if (!valueToApply) {
                // 요청값이 없으면 동일 카드의 기존내용 → 전역 상태 순으로 사용
                valueToApply = (existingInput?.value || '').trim();
                if (!valueToApply) {
                    valueToApply = (promptData?.structuredPrompt?.[key] || '').trim();
                }
            }
            
            if (valueToApply) {
                appliedInput.value = valueToApply;
                // 구조 데이터 즉시 반영하여 프리뷰/저장 동기화
                updateStructureValue(key, valueToApply);
                showToast(requestValue ? '변경요청 내용이 변경반영으로 저장되었습니다.' : '기존 내용이 변경반영으로 복사되었습니다.', 'success');
            } else {
                showToast('변경요청 또는 기존내용이 비어있습니다.', 'error');
            }
        }
        
        // AI저장 버튼 기능 - 저장 버튼과 동일한 동작
        function aiSaveField(key) {
            const dropdownContainer = document.querySelector('.dropdown-container.active');
            if (!dropdownContainer) {
                showToast('드롭다운을 먼저 열어주세요.', 'error');
                return;
            }
            
            const container = dropdownContainer.querySelector('.dropdown-content');
            const requestInput = container.querySelector(`input[data-key="${key}-request"]`);
            const appliedInput = container.querySelector(`input[data-key="${key}-applied"]`);
            const existingInput = container.querySelector(`input[data-key="${key}"]`);
            
            if (!appliedInput) return;
            
            const requestValue = (requestInput?.value || '').trim();
            let valueToApply = requestValue;
            
            if (!valueToApply) {
                // 요청값이 없으면 동일 카드의 기존내용 → 전역 상태 순으로 사용
                valueToApply = (existingInput?.value || '').trim();
                if (!valueToApply) {
                    valueToApply = (promptData?.structuredPrompt?.[key] || '').trim();
                }
            }
            
            if (valueToApply) {
                appliedInput.value = valueToApply;
                // 구조 데이터 즉시 반영하여 프리뷰/저장 동기화
                updateStructureValue(key, valueToApply);
                console.log(`[AI 저장] ${key}: ${valueToApply}`);
            } else {
                console.log(`[AI 저장] ${key}: 비어있음`);
            }
        }
        
        // window 전역 함수로 등록 (인라인 onclick용)
        window.removeImage = removeImage;
        window.editCard = editCard;
        window.saveCard = saveCard;
        window.cancelCard = cancelCard;
        window.importPromptFromPreview = importPromptFromPreview;
        window.handleCardKeydown = handleCardKeydown;
        window.switchStructureTab = switchStructureTab;
        window.switchCharacterSubTab = switchCharacterSubTab;
        window.switchGeneralSubTab = switchGeneralSubTab;
        window.updateStructureValue = updateStructureValue;
        window.toggleDropdown = toggleDropdown;
        window.toggleStyleDropdown = toggleStyleDropdown;
        window.selectStyleOption = selectStyleOption;
        window.saveToApplied = saveToApplied;
        window.aiSaveField = aiSaveField;
        window.filterStyleDropdown = filterStyleDropdown;
        window.filterStyleOptions = filterStyleOptions;
        
        // 프롬프트 입력창 초기화 함수
        function clearPromptInput() {
            const promptPreview = document.getElementById('prompt-preview');
            if (promptPreview) {
                promptPreview.textContent = '';
                userEditingPreview = false;
                showToast('프롬프트가 초기화되었습니다.', 'info');
            }
        }
        
        window.clearPromptInput = clearPromptInput;
        
        // AI 프롬프트 생성 관련 함수들 - 먼저 정의
        async function generateAIPrompt() {
            console.log('AI 프롬프트 생성 시작');
            
            // API 설정 확인
            const config = localStorage.getItem('aiApiConfig');
            if (!config) {
                console.log('API 설정이 없습니다. 모달을 엽니다.');
                showToast('API 설정을 먼저 해주세요.', 'error');
                openApiModal();
                return;
            }
            
            console.log('API 설정 확인:', JSON.parse(config));
            
            // 모든 변경 반영 텍스트창의 내용 수집
            const collectedData = collectAllAppliedData();
            console.log('수집된 데이터:', collectedData);
            
            if (Object.keys(collectedData).length === 0) {
                showToast('변경 반영된 내용이 없습니다.', 'error');
                console.log('변경 반영된 내용이 없어서 종료합니다.');
                return;
            }
            
            // 로딩 상태 표시
            const aiGenerateBtn = document.getElementById('ai-generate-prompt-btn');
            if (!aiGenerateBtn) {
                console.error('AI 프롬프트 생성 버튼을 찾을 수 없습니다.');
                showToast('버튼을 찾을 수 없습니다.', 'error');
                return;
            }
            
            const originalText = aiGenerateBtn.innerHTML;
            aiGenerateBtn.disabled = true;
            aiGenerateBtn.innerHTML = '🔄 AI 프롬프트 생성 중...';
            
            try {
                // AI API를 통한 프롬프트 최적화
                const optimizedPrompt = await optimizePromptWithAI(collectedData);
                
                // 기존 프롬프트와 병합
                mergeOptimizedPrompt(optimizedPrompt);
                
                showToast('AI 프롬프트가 생성되었습니다.', 'success');
            } catch (error) {
                console.error('AI 프롬프트 생성 실패:', error);
                // 더 자세한 오류 메시지 표시
                let errorMessage = 'AI 프롬프트 생성에 실패했습니다.';
                if (error.message.includes('CORS')) {
                    errorMessage = 'CORS 오류: Chrome 확장 프로그램(Allow CORS)을 설치하거나 프록시 서버를 사용해주세요.';
                } else if (error.message.includes('401')) {
                    errorMessage = 'API 키가 유효하지 않습니다. 설정을 확인해주세요.';
                } else if (error.message.includes('404')) {
                    errorMessage = '모델명이 잘못되었습니다. gemini-2.5-flash, gemini-2.5-pro, gemini-2.5-flash-lite 또는 gemini-1.5-flash를 사용해보세요.';
                } else if (error.message.includes('429')) {
                    errorMessage = 'API 요청 한도를 초과했습니다. 잠시 후 다시 시도해주세요.';
                }
                showToast(errorMessage, 'error');
            } finally {
                if (aiGenerateBtn) {
                    aiGenerateBtn.disabled = false;
                    aiGenerateBtn.innerHTML = originalText;
                }
            }
        }
        
        // 함수를 즉시 window에 할당
        window.generateAIPrompt = generateAIPrompt;
        
        // 디버깅을 위한 테스트 함수
        window.testGeminiAPI = async function() {
            console.log('=== Gemini API 디버깅 테스트 시작 ===');
            const config = localStorage.getItem('aiApiConfig');
            if (!config) {
                console.error('API 설정이 없습니다. 먼저 API를 설정해주세요.');
                return;
            }
            
            const parsedConfig = JSON.parse(config);
            console.log('현재 설정:', parsedConfig);
            
            if (parsedConfig.provider !== 'gemini') {
                console.error('Gemini API가 설정되어 있지 않습니다.');
                return;
            }
            
            const testUrl = `https://generativelanguage.googleapis.com/v1beta/models/${parsedConfig.model}:generateContent?key=${parsedConfig.apiKey}`;
            console.log('테스트 URL:', testUrl.replace(parsedConfig.apiKey, 'API_KEY_HIDDEN'));
            
            const testBody = {
                contents: [{
                    parts: [{
                        text: "Hello, please respond with 'Hi' if you receive this message."
                    }]
                }],
                generationConfig: {
                    temperature: 0.1,
                    maxOutputTokens: 50
                }
            };
            
            console.log('요청 본문:', testBody);
            
            try {
                console.log('API 호출 시작...');
                const response = await fetch(testUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(testBody)
                });
                
                console.log('응답 상태:', response.status, response.statusText);
                console.log('응답 헤더:', Object.fromEntries(response.headers.entries()));
                
                const responseText = await response.text();
                console.log('원본 응답:', responseText);
                
                try {
                    const data = JSON.parse(responseText);
                    console.log('파싱된 응답:', data);
                    
                    if (data.candidates && data.candidates[0]) {
                        console.log('✅ API 연결 성공!');
                        console.log('응답 텍스트:', data.candidates[0].content.parts[0].text);
                    } else if (data.error) {
                        console.error('❌ API 오류:', data.error);
                    }
                } catch (e) {
                    console.error('JSON 파싱 실패:', e);
                }
            } catch (error) {
                console.error('❌ 네트워크 오류:', error);
                if (error.message.includes('Failed to fetch')) {
                    console.error('💡 CORS 오류일 가능성이 높습니다.');
                    console.error('해결 방법:');
                    console.error('1. Chrome 확장 프로그램 "Allow CORS" 설치');
                    console.error('2. https://cors-anywhere.herokuapp.com/ 프록시 사용');
                    console.error('3. 백엔드 서버를 통한 API 호출');
                }
            }
            
            console.log('=== 테스트 종료 ===');
        };
        
        // 모든 변경 반영 데이터 수집
        function collectAllAppliedData() {
            const collectedData = {};
            console.log('collectAllAppliedData 함수 시작');
            
            // 모든 드롭다운 컨테이너에서 변경 반영 내용 수집
            const containers = document.querySelectorAll('.dropdown-container');
            console.log('찾은 드롭다운 컨테이너 수:', containers.length);
            
            containers.forEach((container, index) => {
                const appliedInputs = container.querySelectorAll('input[data-key$="-applied"]');
                console.log(`컨테이너 ${index}: 찾은 applied input 수:`, appliedInputs.length);
                
                appliedInputs.forEach(input => {
                    const value = input.value.trim();
                    const key = input.getAttribute('data-key');
                    console.log(`Input key: ${key}, value: ${value}`);
                    
                    if (value) {
                        const cleanKey = key.replace('-applied', '');
                        collectedData[cleanKey] = value;
                    }
                });
            });
            
            // 대체 선택자로 시도
            if (Object.keys(collectedData).length === 0) {
                console.log('기본 선택자로 데이터를 찾지 못했습니다. 대체 방법 시도...');
                
                // 모든 input 요소 중에서 applied 관련 찾기
                const allInputs = document.querySelectorAll('input[type="text"]');
                console.log('전체 텍스트 입력 필드 수:', allInputs.length);
                
                allInputs.forEach(input => {
                    const dataKey = input.getAttribute('data-key');
                    const value = input.value.trim();
                    
                    if (dataKey && dataKey.includes('-applied') && value) {
                        const cleanKey = dataKey.replace('-applied', '');
                        collectedData[cleanKey] = value;
                        console.log(`대체 방법으로 찾은 데이터: ${cleanKey} = ${value}`);
                    }
                });
                
                // 프롬프트 프리뷰에서 직접 가져오기
                if (Object.keys(collectedData).length === 0) {
                    console.log('applied 입력을 찾지 못했습니다. 프롬프트 프리뷰에서 직접 가져옵니다.');
                    const promptPreview = document.getElementById('prompt-preview');
                    if (promptPreview && promptPreview.textContent.trim()) {
                        collectedData['prompt-preview'] = promptPreview.textContent.trim();
                        console.log('프롬프트 프리뷰 내용:', collectedData['prompt-preview']);
                    }
                }
            }
            
            console.log('최종 수집된 데이터:', collectedData);
            return collectedData;
        }
        
        // AI를 통한 프롬프트 최적화 및 영문 번역
        async function optimizePromptWithAI(data) {
            try {
                const configStr = localStorage.getItem('aiApiConfig');
                if (!configStr) {
                    throw new Error('API 설정이 없습니다.');
                }
                
                const config = JSON.parse(configStr);
                if (!config || !config.provider || !config.apiKey || !config.model) {
                    throw new Error('API 설정이 올바르지 않습니다.');
                }
                
                const { provider, apiKey, model } = config;
                
                console.log('=== AI API 설정 ===');
                console.log('Provider:', provider);
                console.log('Model:', model);
                console.log('API Key:', apiKey ? `${apiKey.substring(0, 10)}...` : '없음');
                
                // 각 섹션별로 개별 최적화
                const optimizedData = {};
                
                for (const [key, value] of Object.entries(data)) {
                    if (!value || value.trim() === '') continue;
                    
                    console.log(`\n=== ${key} 섹션 최적화 시작 ===`);
                    console.log('원본:', value);
                    
                    try {
                        const optimizedText = await optimizeSinglePrompt(value, provider, apiKey, model);
                        optimizedData[key] = optimizedText;
                        console.log('최적화 결과:', optimizedText);
                    } catch (error) {
                        console.error(`${key} 최적화 실패:`, error);
                        // 실패 시 원본 사용
                        optimizedData[key] = value;
                    }
                }
                
                return optimizedData;
            } catch (error) {
                console.error('AI 최적화 초기화 실패:', error);
                throw error;
            }
        }
        
        // 단일 프롬프트 최적화 함수 - optimizePromptWithAI보다 먼저 정의
        async function optimizeSinglePrompt(text, provider, apiKey, model) {
            // 수집된 데이터를 프롬프트 텍스트로 변환
            let promptText = '';
            if (typeof text === 'string') {
                promptText = text;
            } else if (text && typeof text === 'object') {
                // 구조화된 데이터인 경우
                promptText = Object.entries(text)
                    .map(([key, value]) => `${key}: ${value}`)
                    .join(', ');
            } else {
                promptText = String(text || '');
            }
            
            console.log('=== 프롬프트 정보 ===');
            console.log('입력 데이터:', text);
            console.log('변환된 프롬프트 텍스트:', promptText);
            console.log('텍스트 길이:', promptText.length);
            
            const systemPrompt = `You are a translator for AI image generation prompts.
Your task is to:
1. Identify Korean text in the input
2. Translate ONLY the Korean parts to English
3. Keep any existing English text exactly as is
4. Do NOT combine or merge the translations with existing English
5. Output ONLY the translated Korean parts without any explanations

Examples:
- Input: "빨간 드레스 red dress" → Output: "red dress"
- Input: "긴 머리 woman with braids" → Output: "long hair"
- Input: "blue eyes 파란 눈" → Output: "blue eyes"`;
            
            try {
                let optimizedText;
                
                if (provider === 'gemini') {
                    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
                    const geminiBody = {
                        contents: [{
                            parts: [{
                                text: `${systemPrompt}\n\nTranslate only Korean parts: ${promptText}`
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.3,
                            maxOutputTokens: 500
                        }
                    };
                    
                    console.log('=== Gemini API 요청 ===');
                    console.log('URL:', geminiUrl.replace(apiKey, 'API_KEY_HIDDEN'));
                    console.log('Model:', model);
                    console.log('Request Body:', JSON.stringify(geminiBody, null, 2));
                    
                    // 지원되는 모델 목록 표시
                    console.log('💡 요청한 모델:', model);
                    console.log('💡 지원되는 Gemini 모델: gemini-2.5-flash, gemini-2.5-pro, gemini-1.5-flash, gemini-1.5-pro');
                    
                    const response = await fetch(geminiUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(geminiBody)
                    });
                    
                    console.log('=== Gemini API 응답 상태 ===');
                    console.log('Status:', response.status);
                    console.log('StatusText:', response.statusText);
                    console.log('Headers:', response.headers);
                    
                    const responseText = await response.text();
                    console.log('Raw Response:', responseText);
                    
                    let data;
                    try {
                        data = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error('JSON 파싱 실패:', parseError);
                        console.error('응답 텍스트:', responseText);
                        throw new Error('API 응답을 파싱할 수 없습니다.');
                    }
                    
                    if (response.ok) {
                        console.log('Parsed Gemini API 응답:', JSON.stringify(data, null, 2));
                        
                        // 다양한 응답 구조 처리
                        if (data && data.candidates && data.candidates.length > 0) {
                            const candidate = data.candidates[0];
                            if (candidate.content && candidate.content.parts && candidate.content.parts.length > 0) {
                                optimizedText = candidate.content.parts[0].text;
                                console.log('Gemini 최적화된 텍스트:', optimizedText);
                            } else if (candidate.text) {
                                // 다른 가능한 응답 구조
                                optimizedText = candidate.text;
                                console.log('Gemini 최적화된 텍스트 (대체 구조):', optimizedText);
                            } else {
                                console.error('Candidate 구조가 예상과 다름:', candidate);
                                throw new Error('응답에서 텍스트를 찾을 수 없습니다.');
                            }
                        } else if (data && data.error) {
                            console.error('Gemini API 에러 응답:', data.error);
                            const errorMessage = data.error.message || data.error.status || '알 수 없는 오류';
                            const errorCode = data.error.code || 'UNKNOWN';
                            throw new Error(`Gemini API 에러 [${errorCode}]: ${errorMessage}`);
                        } else {
                            console.error('예상치 못한 Gemini API 응답 구조:', data);
                            throw new Error('Gemini API 응답 구조가 올바르지 않습니다.');
                        }
                    } else {
                        // 오류 응답 처리
                        console.error('Gemini API 오류 응답:', data);
                        console.error('응답 상태 코드:', response.status);
                        console.error('요청한 모델:', model);
                        
                        if (data && data.error) {
                            const errorMessage = data.error.message || data.error.status || '알 수 없는 오류';
                            const errorCode = data.error.code || response.status;
                            console.error('에러 코드:', errorCode);
                            console.error('에러 메시지:', errorMessage);
                            
                            // 일반적인 오류 메시지 처리
                            let userMessage = errorMessage;
                            if (response.status === 400) {
                                userMessage = 'API 요청이 잘못되었습니다. API 키와 모델명을 확인해주세요.';
                            } else if (response.status === 401) {
                                userMessage = 'API 키가 유효하지 않습니다. 설정을 확인해주세요.';
                            } else if (response.status === 403) {
                                userMessage = 'API 접근이 거부되었습니다. API 키 권한을 확인해주세요.';
                            } else if (response.status === 429) {
                                userMessage = 'API 요청 한도를 초과했습니다. 잠시 후 다시 시도해주세요.';
                            } else if (response.status === 404) {
                                userMessage = '잘못된 모델명입니다. gemini-1.5-flash 또는 gemini-1.5-pro를 사용해보세요.';
                            }
                            
                            throw new Error(`[${errorCode}] ${userMessage}`);
                        } else {
                            throw new Error(`API 요청 실패: ${response.status} ${response.statusText}`);
                        }
                    }
                } else if (provider === 'openai') {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: [
                                {
                                    role: 'system',
                                    content: systemPrompt
                                },
                                {
                                    role: 'user',
                                    content: `Translate only Korean parts: ${promptText}`
                                }
                            ],
                            temperature: 0.3,
                            max_tokens: 500
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('OpenAI API 응답:', data);
                        
                        // 안전한 파싱
                        if (data && data.choices && data.choices[0] && 
                            data.choices[0].message && data.choices[0].message.content) {
                            optimizedText = data.choices[0].message.content;
                            console.log('OpenAI 최적화된 텍스트:', optimizedText);
                        } else if (data && data.error) {
                            console.error('OpenAI API 에러:', data.error);
                            throw new Error(`OpenAI API 에러: ${data.error.message || '알 수 없는 오류'}`);
                        } else {
                            console.error('예상치 못한 OpenAI API 응답 구조:', data);
                            throw new Error('OpenAI API 응답 구조가 올바르지 않습니다.');
                        }
                    } else {
                        const errorData = await response.json().catch(() => null);
                        console.error('OpenAI API 요청 실패:', response.status, errorData);
                        throw new Error(`API 요청 실패: ${response.status} ${errorData?.error?.message || ''}`);
                    }
                }
                
                return optimizedText;
            } catch (error) {
                console.error('단일 프롬프트 최적화 실패:', error);
                
                // CORS 오류 감지
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError') || error.name === 'TypeError') {
                    console.error('🚫 CORS 오류 감지됨!');
                    console.error('해결 방법:');
                    console.error('1. Chrome 확장 프로그램: "Allow CORS" 또는 "CORS Unblock" 설치');
                    console.error('2. 프록시 서버 사용 (https://cors-anywhere.herokuapp.com/ 등)');
                    console.error('3. 로컬 개발 서버에서 CORS 설정');
                    throw new Error('CORS 오류: 브라우저에서 API 호출이 차단되었습니다. 위의 해결 방법을 참고해주세요.');
                }
                
                throw error;
            }
        }
        
        // 최적화된 프롬프트를 기존 내용과 병합
        function mergeOptimizedPrompt(optimizedData) {
            console.log('=== mergeOptimizedPrompt 함수 호출 ===');
            console.log('최적화된 데이터:', optimizedData);
            
            // 1. 각 섹션의 변경 반영 텍스트창에 최적화된 결과 업데이트
            for (const [key, value] of Object.entries(optimizedData)) {
                // 변경 반영 input 찾기
                const appliedInput = document.querySelector(`input[data-key="${key}-applied"]`);
                if (appliedInput) {
                    console.log(`${key} 변경 반영 필드 업데이트:`, value);
                    appliedInput.value = value;
                    // 이벤트 트리거 (변경 사항 추적을 위해)
                    appliedInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
            
            // 2. 모든 변경 반영 데이터로 프롬프트 생성 (일반 프롬프트 생성과 동일한 로직)
            console.log('최종 프롬프트 표시 함수 호출');
            
            // displayFinalPrompt 함수가 존재하는지 확인
            if (typeof displayFinalPrompt === 'function') {
                displayFinalPrompt();
            } else {
                console.error('displayFinalPrompt 함수를 찾을 수 없습니다.');
                
                // Fallback: 최종 프롬프트 셉션 직접 표시
                const finalPromptSection = document.getElementById('final-prompt-section');
                if (finalPromptSection) {
                    finalPromptSection.style.display = 'block';
                    finalPromptSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }
            
            return;
            
            // 기존 코드는 사용하지 않음
            /*
            
            const promptPreview = document.getElementById('prompt-preview');
            const currentPrompt = promptPreview.textContent.trim();
            
            console.log('현재 프롬프트 프리뷰 내용:', currentPrompt);
            
            // 기존 내용과 AI 최적화 내용을 병합
            let mergedPrompt = '';
            if (currentPrompt) {
                mergedPrompt = `${currentPrompt}\n\n[AI Enhanced]\n${optimizedPrompt}`;
            } else {
                mergedPrompt = optimizedPrompt;
            }
            
            // 프롬프트 프리뷰에 표시
            console.log('병합된 프롬프트를 프리뷰에 표시:', mergedPrompt);
            promptPreview.textContent = mergedPrompt;
            promptPreview.classList.add('has-content');
            
            // 프롬프트 구조 편집기로 가져오기
            console.log('importPromptFromPreview 호출');
            importPromptFromPreview();
            
            // 프롬프트 데이터 저장 (일반 프롬프트 생성과 동일)
            const text = currentPrompt || '사용자 입력';
            
            // promptData가 정의되어 있는지 확인
            if (typeof promptData !== 'undefined' && promptData) {
                if (!promptData.generatedPrompts) {
                    promptData.generatedPrompts = [];
                }
                promptData.generatedPrompts.push({
                    timestamp: new Date().toISOString(),
                    input: text,
                    output: mergedPrompt
                });
                
                // saveToLocalStorage 함수가 존재하는지 확인
                if (typeof saveToLocalStorage === 'function') {
                    saveToLocalStorage();
                }
            }
            
            */
        }
        
        // AI 프롬프트 생성 버튼 이벤트 리스너 - DOM 로드 후 연결
        function initializeAIPromptButton() {
            const aiButton = document.getElementById('ai-generate-prompt-btn');
            if (aiButton) {
                // 기존 이벤트 리스너 제거 (중복 방지)
                aiButton.removeEventListener('click', generateAIPrompt);
                
                // 새 이벤트 리스너 추가
                aiButton.addEventListener('click', function(e) {
                    console.log('AI 프롬프트 생성 버튼 클릭됨!');
                    e.preventDefault();
                    generateAIPrompt();
                });
                
                console.log('AI 프롬프트 생성 버튼 초기화 완료');
                console.log('버튼 요소:', aiButton);
                console.log('버튼 ID:', aiButton.id);
                console.log('버튼 onclick:', aiButton.onclick);
                
                // 버튼에 직접 onclick도 추가 (백업)
                aiButton.onclick = function() {
                    console.log('onclick 핸들러 실행됨');
                    generateAIPrompt();
                };
            } else {
                console.error('AI 프롬프트 생성 버튼을 찾을 수 없습니다.');
                
                // 1초 후 재시도
                setTimeout(() => {
                    console.log('버튼 찾기 재시도...');
                    const retryButton = document.getElementById('ai-generate-prompt-btn');
                    if (retryButton) {
                        console.log('재시도에서 버튼 찾음!');
                        initializeAIPromptButton();
                    }
                }, 1000);
            }
        }
        
        // DOM이 완전히 로드된 후 실행
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initializeAIPromptButton();
                });
        } else {
            // 이미 DOM이 로드된 경우 즉시 실행
            initializeAIPromptButton();
        }
        
        // 페이지 로드 완료 후 추가 확인
        window.addEventListener('load', function() {
            console.log('=== 페이지 완전 로드 완료 ===');
            const aiBtn = document.getElementById('ai-generate-prompt-btn');
            console.log('AI 버튼 존재 여부:', !!aiBtn);
            if (aiBtn) {
                console.log('버튼 텍스트:', aiBtn.textContent);
                console.log('버튼 클릭 이벤트 리스너:', aiBtn.onclick);
                console.log('window.generateAIPrompt 존재:', typeof window.generateAIPrompt);
            }
            
            // API 설정 자동 복원 확인
            const savedApiConfig = localStorage.getItem('aiApiConfig');
            if (savedApiConfig) {
                console.log('저장된 API 설정 발견:', JSON.parse(savedApiConfig));
                console.log('API 설정이 localStorage에 저장되어 있으므로 새로고침 후에도 유지됩니다.');
            } else {
                console.log('API 설정이 없습니다.');
            }
            
            // 모든 버튼 확인
            const allButtons = document.querySelectorAll('button');
            console.log('전체 버튼 수:', allButtons.length);
            allButtons.forEach((btn, idx) => {
                if (btn.textContent.includes('AI')) {
                    console.log(`버튼 ${idx}: ${btn.textContent.trim()}, ID: ${btn.id}`);
                }
            });
        });
        
        // API 연동 관련 함수들
        function openApiModal() {
            console.log('openApiModal 함수 호출됨');
            const modal = document.getElementById('api-modal');
            if (!modal) {
                console.error('API 모달 요소를 찾을 수 없습니다!');
                return;
            }
            console.log('모달 찾음, show 클래스 추가 전:', modal.className);
            modal.classList.add('show');
            console.log('show 클래스 추가 후:', modal.className);
            
            // 모달이 실제로 표시되는지 확인
            setTimeout(() => {
                const computedStyle = window.getComputedStyle(modal);
                console.log('모달 display 상태:', computedStyle.display);
                console.log('모달 visibility:', computedStyle.visibility);
            }, 100);
            
            // 저장된 설정 불러오기
            const savedConfig = localStorage.getItem('aiApiConfig');
            if (savedConfig) {
                const config = JSON.parse(savedConfig);
                document.getElementById('api-provider').value = config.provider || '';
                document.getElementById('api-key').value = config.apiKey || '';
                updateModelOptions();
                setTimeout(() => {
                    document.getElementById('api-model').value = config.model || '';
                }, 100);
            } else {
                // 저장된 설정이 없으면 기본값 설정
                document.getElementById('api-provider').value = 'gemini';
                updateModelOptions();
                setTimeout(() => {
                    // Gemini 2.5 Flash를 기본값으로 설정
                    document.getElementById('api-model').value = 'gemini-2.5-flash';
                }, 100);
            }
        }
        
        // 함수를 즉시 window에 할당
        window.openApiModal = openApiModal;

        function closeApiModal() {
            console.log('closeApiModal 함수 호출됨');
            const modal = document.getElementById('api-modal');
            if (!modal) {
                console.error('API 모달 요소를 찾을 수 없습니다!');
                return;
            }
            modal.classList.remove('show');
            console.log('모달 닫기 완료');
            
            // 연결 상태 초기화
            const statusElement = document.getElementById('connection-status');
            if (statusElement) {
                statusElement.className = 'connection-status';
                statusElement.textContent = '';
            }
        }
        
        // 함수를 즉시 window에 할당
        window.closeApiModal = closeApiModal;
        
        // 텍스트 영역 자동 크기 조정 함수
        function autoResizeTextarea(textarea) {
            // 축소 가능하도록 높이 초기화
            textarea.style.height = 'auto';
            
            // 필요한 높이 계산
            const scrollHeight = textarea.scrollHeight;
            const maxHeight = window.innerHeight * 0.8; // 뷰포트의 80%
            
            // 새로운 높이 설정 (10px 여백 추가)
            textarea.style.height = Math.min(scrollHeight + 10, maxHeight) + 'px';
        }
        
        // 측면 뷰 주의사항 모달 관련 함수
        function showSideViewWarning() {
            const modal = document.getElementById('sideViewModal');
            if (modal) {
                modal.classList.add('show');
            }
        }
        
        function closeSideViewModal() {
            const modal = document.getElementById('sideViewModal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        // 전역 함수로 등록
        window.showSideViewWarning = showSideViewWarning;
        window.closeSideViewModal = closeSideViewModal;
        
        // 모달 외부 클릭 시 닫기
        document.addEventListener('DOMContentLoaded', function() {
            const sideViewModal = document.getElementById('sideViewModal');
            if (sideViewModal) {
                sideViewModal.addEventListener('click', function(e) {
                    if (e.target === sideViewModal) {
                        closeSideViewModal();
                    }
                });
            }
            
            // 윈도우 크기 변경 시 최종 프롬프트 텍스트 영역 크기 재조정
            let resizeTimer;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(function() {
                    const finalPromptTextarea = document.getElementById('final-prompt-text');
                    if (finalPromptTextarea && finalPromptTextarea.value) {
                        autoResizeTextarea(finalPromptTextarea);
                    }
                }, 250);
            });
        });

        function updateModelOptions() {
            const provider = document.getElementById('api-provider').value;
            const modelSelect = document.getElementById('api-model');
            const modelGroup = document.getElementById('model-group');
            const apiInfo = document.getElementById('api-info');
            
            // 모델 옵션 초기화
            modelSelect.innerHTML = '<option value="">모델을 선택하세요</option>';
            
            if (!provider) {
                modelGroup.style.display = 'none';
                apiInfo.style.display = 'none';
                return;
            }
            
            modelGroup.style.display = 'block';
            apiInfo.style.display = 'block';
            
            if (provider === 'gemini') {
                apiInfo.innerHTML = '💡 Google AI Studio에서 API 키를 발급받으세요. <a href="https://makersuite.google.com/app/apikey" target="_blank" style="color: #3b82f6;">API 키 발급하기</a>';
                const geminiModels = [
                    { value: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash (최신, 추천)' },
                    { value: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro (고급)' },
                    { value: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash-Lite (경량)' },
                    { value: 'gemini-1.5-flash', name: 'Gemini 1.5 Flash' },
                    { value: 'gemini-1.5-pro', name: 'Gemini 1.5 Pro' },
                    { value: 'gemini-pro', name: 'Gemini Pro' }
                ];
                geminiModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.value;
                    option.textContent = model.name;
                    modelSelect.appendChild(option);
                });
            } else if (provider === 'openai') {
                apiInfo.innerHTML = '💡 OpenAI Platform에서 API 키를 발급받으세요. <a href="https://platform.openai.com/api-keys" target="_blank" style="color: #3b82f6;">API 키 발급하기</a>';
                const openaiModels = [
                    { value: 'gpt-4o', name: 'GPT-4o (최신, 추천)' },
                    { value: 'gpt-4o-mini', name: 'GPT-4o Mini (경제적)' },
                    { value: 'gpt-4-turbo', name: 'GPT-4 Turbo' },
                    { value: 'gpt-4', name: 'GPT-4' },
                    { value: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo' },
                    { value: 'o1-preview', name: 'o1 Preview (추론 특화)' },
                    { value: 'o1-mini', name: 'o1 Mini (추론 특화, 경제적)' }
                ];
                openaiModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.value;
                    option.textContent = model.name;
                    modelSelect.appendChild(option);
                });
            }
        }

        async function autoTestConnection() {
            const provider = document.getElementById('api-provider').value;
            const apiKey = document.getElementById('api-key').value;
            
            if (provider && apiKey && apiKey.length > 20) {
                // 모델 선택은 자동으로 첫 번째 모델로 설정
                const modelSelect = document.getElementById('api-model');
                if (modelSelect.options.length > 1) {
                    modelSelect.selectedIndex = 1;
                }
                await testApiConnection();
            }
        }
        
        async function testApiConnection() {
            const provider = document.getElementById('api-provider').value;
            const apiKey = document.getElementById('api-key').value;
            const model = document.getElementById('api-model').value || document.getElementById('api-model').options[1]?.value;
            const statusDiv = document.getElementById('connection-status');
            
            if (!provider || !apiKey) {
                showToast('제공자와 API 키를 입력해주세요.', 'error');
                return;
            }
            
            statusDiv.className = 'connection-status';
            statusDiv.textContent = '연결 테스트 중...';
            statusDiv.style.display = 'block';
            
            try {
                let response;
                
                if (provider === 'gemini') {
                    // Gemini API 테스트
                    response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: "Say 'Hello'"
                                }]
                            }]
                        })
                    });
                } else if (provider === 'openai') {
                    // OpenAI API 테스트
                    response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: [{
                                role: 'user',
                                content: 'Say "Hello"'
                            }],
                            max_tokens: 10
                        })
                    });
                }
                
                if (response.ok) {
                    statusDiv.className = 'connection-status success';
                    statusDiv.textContent = '✓ 연결 성공! API가 정상적으로 작동합니다.';
                    document.getElementById('save-api-btn').disabled = false;
                } else {
                    const error = await response.json();
                    statusDiv.className = 'connection-status error';
                    statusDiv.textContent = `✗ 연결 실패: ${error.error?.message || '잘못된 API 키 또는 설정입니다.'}`;
                    document.getElementById('save-api-btn').disabled = true;
                }
            } catch (error) {
                statusDiv.className = 'connection-status error';
                statusDiv.textContent = `✗ 연결 실패: ${error.message}`;
                document.getElementById('save-api-btn').disabled = true;
            }
        }

        function saveApiConfig() {
            console.log('=== saveApiConfig 함수 호출 ===');
            
            const provider = document.getElementById('api-provider').value;
            const apiKey = document.getElementById('api-key').value;
            const model = document.getElementById('api-model').value;
            
            console.log('입력된 값들:');
            console.log('Provider:', provider);
            console.log('API Key:', apiKey ? `${apiKey.substring(0, 10)}...` : '없음');
            console.log('Model:', model);
            
            if (!provider || !apiKey || !model) {
                showToast('모든 필드를 입력해주세요.', 'error');
                return;
            }
            
            const config = {
                provider: provider,
                apiKey: apiKey,
                model: model
            };
            
            console.log('저장할 설정:', config);
            localStorage.setItem('aiApiConfig', JSON.stringify(config));
            
            // 저장 확인
            const savedConfig = localStorage.getItem('aiApiConfig');
            console.log('저장된 설정 확인:', savedConfig);
            
            showToast('API 설정이 저장되었습니다.', 'success');
            closeApiModal();
        }

        // AI를 통한 프롬프트 향상 함수
        async function enhancePromptWithAI(text) {
            try {
                const configStr = localStorage.getItem('aiApiConfig');
                if (!configStr) {
                    console.log('API 설정이 없어서 기본 향상 함수 사용');
                    return enhancePrompt(text); // 기존 로직으로 폴백
                }
                
                const config = JSON.parse(configStr);
                if (!config || !config.provider || !config.apiKey || !config.model) {
                    console.log('API 설정이 불완전하여 기본 향상 함수 사용');
                    return enhancePrompt(text); // 기존 로직으로 폴백
                }
                
                const { provider, apiKey, model } = config;
            
            try {
                let enhancedText;
                const systemPrompt = `You are an expert at creating detailed image generation prompts. Enhance the following request into a detailed, descriptive prompt for AI image generation. Include specific details about style, lighting, composition, colors, and atmosphere. Keep the response concise but descriptive. Respond in the same language as the input.`;
                
                if (provider === 'gemini') {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: `${systemPrompt}\n\nEnhance this prompt: ${text}`
                                }]
                            }],
                            generationConfig: {
                                temperature: 0.7,
                                maxOutputTokens: 500
                            }
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        enhancedText = data.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error('API 요청 실패');
                    }
                } else if (provider === 'openai') {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: [
                                {
                                    role: 'system',
                                    content: systemPrompt
                                },
                                {
                                    role: 'user',
                                    content: `Enhance this prompt: ${text}`
                                }
                            ],
                            temperature: 0.7,
                            max_tokens: 500
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        enhancedText = data.choices[0].message.content;
                    } else {
                        throw new Error('API 요청 실패');
                    }
                }
                
                return enhancedText || enhancePrompt(text);
            } catch (apiError) {
                console.error('AI API 요청 실패:', apiError);
                return enhancePrompt(text); // 기존 로직으로 폴백
            }
            } catch (parseError) {
                console.error('API 설정 파싱 오류:', parseError);
                return enhancePrompt(text); // 기존 로직으로 폴백
            }
        }
        
        // 이미 위에서 정의된 window 함수들은 제거 (중복 방지)
        // window.openApiModal은 이미 4107줄에서 정의됨
        window.updateModelOptions = updateModelOptions;
        window.testApiConnection = testApiConnection;
        window.saveApiConfig = saveApiConfig;
        window.autoTestConnection = autoTestConnection;
    </script>
    
    <!-- API 연동 모달 -->
    <div id="api-modal" class="modal-overlay">
        <div class="modal-container">
            <div class="modal-header">
                <h3 class="modal-title"><span style="font-size: 1.2rem;">🤖</span> AI API 연동 설정</h3>
                <button class="modal-close" onclick="closeApiModal()">×</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="api-provider">AI 제공자 선택</label>
                    <select id="api-provider" class="form-select" onchange="updateModelOptions()">
                        <option value="">제공자를 선택하세요</option>
                        <option value="gemini">Google Gemini</option>
                        <option value="openai">OpenAI</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="api-key">API 키</label>
                    <input type="password" id="api-key" class="form-input" placeholder="API 키를 입력하세요" onpaste="setTimeout(() => autoTestConnection(), 100)" onkeyup="if(event.key === 'Enter') autoTestConnection()">
                    <div id="api-info" class="api-info" style="display: none;"></div>
                </div>
                
                <div class="form-group" id="model-group" style="display: none;">
                    <label class="form-label" for="api-model">연결 모델</label>
                    <select id="api-model" class="form-select">
                        <option value="">모델을 선택하세요</option>
                    </select>
                </div>
                
                <div id="connection-status" class="connection-status"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-cancel" onclick="closeApiModal()">취소</button>
                <button class="btn btn-test" onclick="testApiConnection()">연결 테스트</button>
                <button id="save-api-btn" class="btn btn-save" onclick="saveApiConfig()" disabled>저장</button>
            </div>
        </div>
    </div>
    
    <!-- 측면 뷰 주의사항 모달 -->
    <div id="sideViewModal" class="modal">
        <div class="modal-content side-view-modal">
            <div class="modal-header">
                <h3>⚠️ 측면 뷰 선택 - 수정 필요 항목</h3>
                <button class="modal-close" onclick="window.closeSideViewModal()">×</button>
            </div>
            <div class="modal-body">
                <h4 style="color: white; font-size: 1.2rem; margin-bottom: 24px;">측면 프로필 촬영 시:</h4>
                
                <div style="background: rgba(40, 40, 45, 0.6); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                    <div style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 16px;">
                        <input type="checkbox" style="margin-top: 3px;" disabled>
                        <div>
                            <span style="color: #ff9800; font-weight: 600;">FACE_SHAPE</span>
                            <span style="color: rgba(255, 255, 255, 0.9);"> - 삭제 권장 (정면 기준이므로)</span>
                        </div>
                    </div>
                    
                    <div style="display: flex; align-items: flex-start; gap: 12px; margin-bottom: 16px;">
                        <input type="checkbox" style="margin-top: 3px;" disabled>
                        <div>
                            <span style="color: #ff9800; font-weight: 600;">FACIAL_FEATURES</span>
                            <span style="color: rgba(255, 255, 255, 0.9);"> - 측면용으로 수정</span>
                            <div style="color: rgba(255, 255, 255, 0.6); font-size: 0.9rem; margin-top: 8px; padding-left: 4px;">
                                예시: "defined nose bridge, strong jawline, visible eyelashes from side"
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; align-items: flex-start; gap: 12px;">
                        <input type="checkbox" style="margin-top: 3px;" disabled>
                        <div>
                            <span style="color: #ff9800; font-weight: 600;">GAZE</span>
                            <span style="color: rgba(255, 255, 255, 0.9);"> - "looking straight ahead" (완벽한 측면)</span>
                        </div>
                    </div>
                </div>
                
                <div class="warning-note" style="background: linear-gradient(135deg, rgba(33, 150, 243, 0.1) 0%, rgba(3, 169, 244, 0.1) 100%); border: 1px solid rgba(33, 150, 243, 0.3);">
                    <p style="color: #2196f3; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 1.2rem;">💡</span>
                        <strong>TIP:</strong> 측면에서는 코의 형태, 턱선, 입술 윤곽이 중요하므로 이를 중심으로 설명하세요.
                    </p>
                </div>
                
                <div style="display: flex; justify-content: flex-end; margin-top: 24px;">
                    <button onclick="window.closeSideViewModal()" style="
                        background: linear-gradient(135deg, #10b981 0%, #059669 100%);
                        color: white;
                        border: none;
                        padding: 12px 32px;
                        border-radius: 8px;
                        font-size: 1rem;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.3)';" 
                       onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                        확인
                    </button>
                </div>
            </div>
        </div>
    </div>
    
</body>
</html>